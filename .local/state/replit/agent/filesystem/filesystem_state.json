{"file_contents":{"src/utils/helperFunctions.js":{"content":"// const xlsx = require(\"xlsx\");\nconst fs = require(\"fs/promises\");\nconst path =  require('path');\nconst jwt = require('jsonwebtoken');\nconst nodemailer = require('nodemailer');\nconst bcrypt = require('bcrypt');\nconst axios = require('axios');\nconst mongoose = require('mongoose');\n\nconst sendGrid = require('../config/sendgrid');\nconst ObjectId = mongoose.Types.ObjectId;\nconst { closeWS, clearRealTimeSessions, clearChatHistory } = require('../modules/v1/AI/controller');\n\nconst MessageModel = require('../models/messages');\nconst ChatRoomModel = require('../models/chat_rooms');\n\nconst getJWTToken = (data, time)=>{\n\n    const token = jwt.sign(data, process.env.JWT_SECRET_KEY, {expiresIn : time})\n    return token;\n}\n\nconst sendEmail = (email, subject, text)=>{\n    \n    const message = {\n        to : email,\n        from : process.env.SENDER_EMAIL,\n        subject : subject,\n        text : text\n    }\n\n    sendGrid.send(message)\n    .then(response => console.log('Email sent : ', response))\n    .catch(error => console.log('Error in email sending : ', error));\n    // const transporter = nodemailer.createTransport({\n    //     service: 'gmail',\n    //     auth: {\n    //         user: process.env.SMTP_EMAIL,\n    //         pass: process.env.SMTP_PASSWORD\n    //     }\n    // });\n\n    // const mailOptions = {\n    //     from: process.env.SMTP_EMAIL,\n    //     to: email,\n    //     subject: subject,\n    //     text: text\n    // };\n\n    // console.log(process.env.SMTP_EMAIL, process.env.SMTP_PASSWORD)\n    // transporter.sendMail(mailOptions, function(error, info){\n    //     if (error) {\n    //         console.log(error);\n    //     } else {\n    //         console.log('Email sent: ' + info.response);\n    //     }\n    // });\n}\n\n\n// const sendOTP = (phone, OTP)=>{\n//     const accountSid = process.env.TWILIO_ACCOUNT_SID;\n//     const authToken = process.env.TWILIO_AUTH_TOKEN;\n\n//     const client = require('twilio')(accountSid, authToken);\n\n//     client.messages\n//     .create({\n//         messagingServiceSid: process.env.TWILIO_MESSAGING_SERVICE_SID,\n//         to: phone,\n//         body: `Your Verification OTP is ${OTP}`,\n//     })\n//     .then(message => {\n//         console.log(`âœ…TWILIO OTP sent: ${OTP} | SID: ${message.sid}`);\n//     })\n//     .catch(err => {\n//         console.error('âŒTWILIO Failed to send OTP:', err);\n//     });\n\n//     // client.verify.v2.services(process.env.TWILIO_MESSAGING_SERVICE_ID)\n//     //   .verifications\n//     //   .create({to: '+919982019540', channel: 'sms'})\n//     //   .then(verification => console.log(verification.sid));\n\n//     // console.log('-----------sendOTP', accountSid, authToken, client);\n//     // client.verify.v2.services(process.env.TWILIO_MESSAGING_SERVICE_ID)\n//     //     .verificationChecks\n//     //     .create({to: '+918000727389', code: '989898'})\n//     //     .then(verification_check => console.log(verification_check.status));\n// }\n\nconst decodeToken = (token)=>{\n    try {\n        const decodedToken = jwt.verify(token, process.env.JWT_SECRET_KEY);\n        return decodedToken;\n    } catch (error) {\n        return {\n            isError: true\n        }\n    }\n}\n\nconst hashPassword =async (password)=>{\n    const hashedPassword = await bcrypt.hash(password, Number(process.env.BCRYPT_ROUNDS));\n    return hashedPassword;\n}\n\nconst matchPassword = async(password, hashedPassword)=>{\n    return await bcrypt.compare(password, hashedPassword);\n}\n\nconst getLocationUsingCoordinates = async(lat, long)=>{\n    if(!(lat && long))return {};\n\n    const response = await axios(\n        `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${long}`,\n         {\n            headers: {\n                // Must clearly identify your app and provide contact info\n                \"User-Agent\": `AI-Marketplace/1.0 (${process.env.SERVER_DOMAIN};)`,\n                // Optional but helpful if routed through your domain\n                \"Referer\": process.env.SERVER_URL\n            }\n        }\n    );\n    // console.log(response.data.address);\n    return response.data.address;\n}\nconst getCityNameUsingLocation=(location)=>{\n  return (\n    location.city\n    || location.town\n    || location.village\n    || location.hamlet\n    || location.municipality\n    || location.county\n    || location.state\n    || location.country\n  );\n}\nfunction toRadians(deg) {\n  return deg * (Math.PI / 180);\n}\n//haversine formula to calulate dist. btw coordinates \n//returns in Meters\nfunction getDistanceBetweenCoordinates(lat1, lon1, lat2, lon2) {\n    if(!(lat1 && lon1) || !(lat2 && lon2))return 0;\n    const R = 6371e3; // Earth mean radius in meters (use 6371 for km)\n    const Ï†1 = toRadians(lat1);\n    const Ï†2 = toRadians(lat2);\n    const Î”Ï† = toRadians(lat2 - lat1);\n    const Î”Î» = toRadians(lon2 - lon1);\n\n    const a =\n        Math.sin(Î”Ï† / 2) * Math.sin(Î”Ï† / 2) +\n        Math.cos(Ï†1) * Math.cos(Ï†2) *\n        Math.sin(Î”Î» / 2) * Math.sin(Î”Î» / 2);\n\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c; // distance in meters\n}\n\n\nconst createOffer=async(data)=>{\n    const offer = {\n        sender: data.senderId,\n        receiver: data.receiverId,\n        message_type: 'offer',\n        offered_price: data.offered_price,\n        offer_status: 'pending',\n        offered_by: data.senderId\n    }\n\n    const offerCreated = await MessageModel.create(offer);\n    return offerCreated._id;\n}\nconst acceptOffer=async(data)=>{\n    const offerUpdated = {\n        offer_status: 'accepted',\n        offered_by: data.acceptedBy\n    }\n\n    await MessageModel.updateOne({_id: data.offerId}, { $set: offerUpdated});\n}\nconst rejectOffer=async(data)=>{\n    const offerUpdated = {\n        offer_status: 'rejected',\n        offered_by: data.declinedBy\n    }\n\n    await MessageModel.updateOne({_id: data.offerId}, { $set: offerUpdated});\n}\n\nconst getChatRoomId = async(senderId, receiverId) =>{\n    const filter = {\n        sender: { $in: [new ObjectId(senderId), new ObjectId(receiverId)] },\n        receiver: { $in: [new ObjectId(senderId), new ObjectId(receiverId)] },\n    };\n\n    let room = await ChatRoomModel.findOne(filter);\n    if(!room){\n        room = await ChatRoomModel.create({sender: senderId, receiver: receiverId});\n    }   \n    return room._id.toString();\n}\n\nconst clearPreviousChatWebSocket= (userId)=>{\n    //clearing chatbot streaming ws-connections and chatHistory\n    closeWS(userId);\n    clearRealTimeSessions(userId);\n    clearChatHistory(userId);\n}\n\nmodule.exports = {\n    getJWTToken, \n    sendEmail, \n    decodeToken, \n    hashPassword, \n    matchPassword, \n    getLocationUsingCoordinates, \n    getCityNameUsingLocation,\n    getDistanceBetweenCoordinates,\n    createOffer, \n    acceptOffer, \n    rejectOffer, \n    getChatRoomId,\n    clearPreviousChatWebSocket\n}\n","path":null,"size_bytes":6801,"size_tokens":null},"src/models/global_settings.js":{"content":"\nconst  mongoose = require(\"mongoose\");\nconst ObjectId = mongoose.Schema.Types.ObjectId;\n\nconst Schema = new mongoose.Schema(\n  {\n    commission_rate: {\n      type: Number,\n      required: true,\n      default: 2\n    },\n    description: {\n      type: String,\n    },\n    commission_earned: {\n      type: Number,\n    },\n    support_email: {\n      type : String,  \n    },\n    support_phone_number: { \n        type: Number\n    },\n  },\n  { timestamps: true }\n);\n\nmodule.exports = mongoose.model(\"global_settings\", Schema);","path":null,"size_bytes":516,"size_tokens":null},"openai_streaming.testing.js":{"content":"","path":null,"size_bytes":0,"size_tokens":null},"src/modules/v1/auth/controller.js":{"content":"\nconst userModel = require('../../../models/users');\nconst { getJWTToken, sendEmail, decodeToken, hashPassword, matchPassword } = require('../../../utils/helperFunctions');\nconst { CustomError } = require('../../../utils/customError');\n\nmodule.exports = {\n    register : async(req, res, next) =>{\n        try {\n            const {name, phone, email, password, confirm_password} = req.body;\n\n            const user = await userModel.findOne({\n                $or : [\n                    {phone},\n                ]\n            });\n            if(user){\n                throw new CustomError(400, 'Phone already exists');\n            }\n            if(password != confirm_password){\n                throw new CustomError(400, 'Password not matched');\n            }\n\n            const data = {\n                name,\n                phone,\n                email,\n                password : await hashPassword(password),\n                otp : 1234,\n                otp_check_remaining_limit : 3,\n                otp_expiry_time : new Date(Date.now() + 3*60*1000),\n                otp_type : 'logged_in'\n            }\n            const userCreated = await userModel.create(data);\n\n            const response = {\n                user_id : userCreated._id\n            }\n            res.status(201)\n            .json({success : true, message : 'Please check your mobile for OTP', response});\n        } catch (error) {\n            next(error);\n        }\n    },\n    verifyOTP : async(req, res, next) =>{\n        try {\n            let { otp, user_id} = req.body;\n\n            const user = await userModel.findOne({_id : user_id});\n            if(!user){\n                throw new CustomError(400, 'User not registered');\n            }else if(!user.otp || user.otp_type != 'logged_in' ){\n                throw new CustomError(400, 'OTP is invalid');\n            }\n\n            const otpExpiryTime = (new Date(user.otp_expiry_time)).getTime();\n            if(otpExpiryTime < Date.now()){\n                throw new CustomError(400, 'OTP has expired');\n            }else if(!user.otp_check_remaining_limit){\n                throw new CustomError(400, 'OTP check limit ended');\n            }else if(user.otp != otp){\n                user.otp_check_remaining_limit -= 1;\n                await user.save();\n                throw new CustomError(400, 'OTP is Invalid');\n            }\n\n            user.otp = null;\n            user.otp_check_remaining_limit = null;\n            user.otp_expiry_time =null;\n            user.otp_type = null;\n\n            const jwtPayload = {\n                _id : user._id,\n                access_type : 'logged_in'\n            }\n            const token = getJWTToken(jwtPayload, '30d');\n            user.access_token = token;\n            await user.save();\n\n            const response = {\n                _id : user._id,\n                name : user.name,\n                email : user.email,\n                phone : user.phone,\n                access_token : token\n            }\n            return res\n                .status(200)\n                .json({success : true, message : 'User verified successfully', data : response});\n\n        } catch (error) {\n            next(error);\n        }\n    },\n    resendOTP : async(req, res, next) =>{\n        try {\n            const {phone, otp_type} = req.body;\n\n            const user = await userModel.findOne({phone});\n            if(!user){\n                throw new CustomError(400, 'User not registered');\n            }\n\n            user.otp = 1234;\n            user.otp_check_remaining_limit = 3;\n            user.otp_expiry_time = new Date(Date.now() + 3*60*1000);\n            user.otp_type = otp_type == 'forgot_password' ? 'forgot_password' : 'logged_in';\n\n            await user.save();\n\n            const data = {\n                user_id : user._id,\n            }\n            // const token = getJWTToken(data, 300);            \n\n            // const emailSubject = 'Verify your email to reset the password!'\n            // const emailVerifyLink = `${process.env.MOBILE_APP_RESET_PASSWORD_PAGE_PATH}?token=${token}`;\n            // const emailText = `Please click on the link given below to reset your password \\n ${emailVerifyLink}`\n            // sendEmail(email, emailSubject, emailText);\n\n            res.status(201)\n            .json({success : true, message : 'A OTP has been sent to your Phone', data});\n        } catch (error) {\n            next(error);\n        }\n    },\n    resetPassword : async(req, res, next) =>{\n        try {\n            const {user_id, password, confirm_password, otp} = req.body;\n            \n            const user = await userModel.findOne({_id : user_id});\n            if(!user){\n                throw new CustomError(400, 'User not registered');\n            }else if(!user.otp || user.otp_type != 'forgot_password' ){\n                throw new CustomError(400, 'OTP is invalid');\n            }\n\n            if(password != confirm_password){\n                throw new CustomError(400, 'Confirm password not matched');\n            }else if(await matchPassword(password, user.password)){\n                throw new CustomError(400, 'New password can\\'t be same as old password');\n            }\n\n            const otpExpiryTime = (new Date(user.otp_expiry_time)).getTime();\n            if(otpExpiryTime < Date.now()){\n                throw new CustomError(400, 'OTP has expired');\n            }else if(!user.otp_check_remaining_limit){\n                throw new CustomError(400, 'OTP check limit ended');\n            }else if(user.otp != otp){\n                user.otp_check_remaining_limit -= 1;\n                await user.save();\n                throw new CustomError(400, 'OTP is Invalid');\n            }\n\n            user.otp = null;\n            user.otp_check_remaining_limit = null;\n            user.otp_expiry_time =null;\n            user.otp_type = null;\n            // const decodedToken = decodeToken(token);\n            // if(decodedToken.access_type != 'forgot_password'){\n            //     throw new CustomError(400, 'Invalid token');\n            // }else if(password != confirm_password){\n            //     throw new CustomError(400, 'Confirm password not matched');\n            // }\n\n            // if(await matchPassword(password, user.password)){\n            //     throw new CustomError(400, 'New password can\\'t be same as old');\n            // }\n\n            user.password = await hashPassword(password);\n            await user.save();\n\n            // const emailSubject = 'Password reset successfully'\n            // const emailText = `Password has been updated successfully`\n            // sendEmail(user.email, emailSubject, emailText);\n\n            res.status(201)\n            .json({success : true, message : 'Password has been reset successfully'});\n        } catch (error) {\n            next(error);\n        }\n    },\n    loginByPhone : async(req, res, next) =>{\n        try {\n            const {phone} = req.body;\n\n            const user = await userModel.findOne({phone});\n            if(!user){\n                throw new CustomError(401, 'User not registered', 'login');\n            }\n            user.otp = 1234;\n            user.otp_check_remaining_limit = 3;\n            user.otp_expiry_time = new Date(Date.now() + 3*60*1000);\n            user.otp_type = 'logged_in';\n            await user.save();\n\n            const response = {\n                user_id : user._id\n            }\n            res.status(201)\n            .json({success : true, message : 'Please check your mobile for OTP', response});\n        } catch (error) {\n            next(error);\n        }\n    },\n    loginByEmail : async(req, res, next) =>{\n        try {\n            const {email, password} = req.body;\n\n            const user = await userModel.findOne({email});\n            if(!user){\n                throw new CustomError(401, 'User not registered', 'login');\n            }\n\n            const isMatched = await matchPassword(password, user.password);\n            if(!isMatched){\n                throw new CustomError(401, 'Invalid credentials', 'login');\n            }\n\n            const jwtPayload = {\n                _id : user._id,\n                access_type : 'logged_in'\n            }\n            const token = getJWTToken(jwtPayload, '30d');\n            user.access_token = token;\n            await user.save();\n\n            const response = {\n                _id : user._id,\n                name : user.name,\n                email : user.email,\n                phone : user.phone,\n                access_token : token\n            }\n            console.log(response, '============Log-in-API response to client');\n            return res\n                .status(200)\n                .json({success : true, message : 'User verified successfully', data : response});\n        } catch (error) {\n            next(error);\n        }\n    },\n}","path":null,"size_bytes":8841,"size_tokens":null},"src/modules/v1/AI/controller copy.js":{"content":"const express=require('express');\nconst router = express.Router();\nconst { OpenAI } = require('openai');\n\nconst { CustomError } = require('../../../utils/customError');\nconst { getSocketIO } = require('../../../config/socket/socket_service');\n\nconst openai = new OpenAI({ apiKey : process.env.OPEN_API_KEY });\n\n\nconst categories = [\n  {\n    \"category\": \"Fashion\",\n    \"subcategories\": [\n      \"jeans\", \"shirts\", \"t-shirts\", \"polo shirts\", \"shorts\",\n      \"jackets\", \"sweatshirts\", \"hoodies\", \"skirts\", \"dresses\",\n      \"handbags\", \"watches\", \"shoes\", \"socks\", \"underwear\",\n      \"belts\", \"scarves\", \"sunglasses\"\n    ]\n  },\n  {\n    \"category\": \"Electronics\",\n    \"subcategories\": [\n      \"mobile phones\", \"laptops\", \"cameras\", \"headphones\",\n      \"smartwatches\", \"smart speakers\", \"televisions\", \"tablets\",\n      \"wireless earbuds\", \"routers\", \"external hard drives\",\n      \"printers\", \"monitors\", \"game consoles\"\n    ]\n  },\n  {\n    \"category\": \"Home & Kitchen\",\n    \"subcategories\": [\n      \"cookware\", \"bedding\", \"sofas\", \"dining tables\",\n      \"small kitchen appliances\", \"vacuum cleaners\", \"wall art\",\n      \"bath towels\", \"kitchen utensils\", \"coffee makers\",\n      \"mattresses\", \"desk chairs\"\n    ]\n  },\n  {\n    \"category\": \"Beauty & Personal Care\",\n    \"subcategories\": [\n      \"skincare\", \"lipstick\", \"perfume\", \"shampoo\",\n      \"conditioner\", \"body lotion\", \"oral care\", \"makeup brushes\",\n      \"hair coloring\", \"face serums\", \"facial cleansers\"\n    ]\n  },\n  {\n    \"category\": \"Books\",\n    \"subcategories\": [\n      \"fiction\", \"non-fiction\", \"childrenâ€™s books\", \"textbooks\",\n      \"audiobooks\", \"ebooks\", \"comics\", \"self-help\", \"cookbooks\"\n    ]\n  },\n  {\n    \"category\": \"Toys & Games\",\n    \"subcategories\": [\n      \"board games\", \"puzzles\", \"action figures\", \"educational toys\",\n      \"electronic toys\", \"dolls\", \"outdoor play\", \"video games\"\n    ]\n  },\n  {\n    \"category\": \"Sports & Outdoors\",\n    \"subcategories\": [\n      \"fitness equipment\", \"camping gear\", \"cycling\",\n      \"team sports gear\", \"yoga mats\", \"running shoes\",\n      \"swimwear\", \"exercise accessories\"\n    ]\n  },\n  {\n    \"category\": \"Pet Supplies\",\n    \"subcategories\": [\n      \"dog food\", \"cat food\", \"aquatic supplies\", \"pet grooming tools\",\n      \"pet toys\", \"pet beds\", \"bird supplies\", \"reptile accessories\"\n    ]\n  },\n  {\n    \"category\": \"Health & Household\",\n    \"subcategories\": [\n      \"vitamins\", \"supplements\", \"medical supplies\", \"cleaning products\",\n      \"personal care essentials\", \"first aid kits\", \"nutrition bars\"\n    ]\n  },\n  {\n    \"category\": \"Tools & Home Improvement\",\n    \"subcategories\": [\n      \"power tools\", \"hand tools\", \"hardware\", \"paint supplies\",\n      \"safety gear\", \"tool storage\", \"plumbing tools\", \"electrical tools\"\n    ]\n  },\n  {\n    \"category\": \"Industrial & Scientific\",\n    \"subcategories\": [\n      \"lab supplies\", \"safety equipment\", \"test & measurement devices\",\n      \"industrial power supplies\", \"scientific instruments\"\n    ]\n  },\n  {\n    \"category\": \"Musical Instruments & Video Games\",\n    \"subcategories\": [\n      \"guitars\", \"keyboards\", \"drums\", \"audio interfaces\",\n      \"video games\", \"game consoles\", \"PC software\"\n    ]\n  }\n]\n\nconst MAX_QUERY_LENGTH = 500; // Adjust based on model's token limits\n\nconst systemPrompt = `You are a focused sales assistant helping users buy or sell products.\n\nðŸŽ¯ Your job:\n- Understand the user's intent (buy or sell).\n- Ask clear, non-repeating follow-up questions about the product (model, brand, condition, price, etc.).\n- These Follow-up questions must be in some priority not random order.\n  1. Main Goal â†’ First, ask about the key product needs such as model, brand, condition (new/used), and price range.\n  2. Specific Details â†’ Next, ask about important preferences like features, size, color, or style.\n  Also don't ask all of these in single go.\n- Only ask 1-2 follow-up questions at a time not multiple questions, follow-up question should not be long.\n- If the user says single-word-input or short sentence then also ask good follow-up question for that.\n- You can ask upto 5-6 follow-up Questions.\n- Stay on product-related topics only, If the user asks personal or off-topic questions then Remind them \n  you're a sales assistant within this app and guide back to the product.\n- If the user asks about product availability or show me products, Then reply:\n  \"I'm currently gathering all the necessary product details. Once I have everything, I can show you the best matching products\", \n  And guide back to the product.\n\n\nCategories and Subcategories for any Product must be:\n[\n  {\"category\": \"Fashion\", \"subcategories\": [\"jeans\", \"shirts\", \"t-shirts\", \"polo shirts\", \"shorts\", \"jackets\", \"sweatshirts\", \"hoodies\", \"skirts\", \"dresses\", \"handbags\", \"watches\", \"shoes\", \"socks\", \"underwear\", \"belts\", \"scarves\", \"sunglasses\"]},\n  {\"category\": \"Electronics\", \"subcategories\": [\"mobile phones\", \"laptops\", \"cameras\", \"headphones\", \"smartwatches\", \"smart speakers\", \"televisions\", \"tablets\", \"wireless earbuds\", \"routers\", \"external hard drives\", \"printers\", \"monitors\", \"game consoles\"]},\n  {\"category\": \"Home & Kitchen\", \"subcategories\": [\"cookware\", \"bedding\", \"sofas\", \"dining tables\", \"small kitchen appliances\", \"vacuum cleaners\", \"wall art\", \"bath towels\", \"kitchen utensils\", \"coffee makers\", \"mattresses\", \"desk chairs\"]},\n  {\"category\": \"Beauty & Personal Care\", \"subcategories\": [\"skincare\", \"lipstick\", \"perfume\", \"shampoo\", \"conditioner\", \"body lotion\", \"oral care\", \"makeup brushes\", \"hair coloring\", \"face serums\", \"facial cleansers\"]},\n  {\"category\": \"Books\", \"subcategories\": [\"fiction\", \"non-fiction\", \"childrenâ€™s books\", \"textbooks\", \"audiobooks\", \"ebooks\", \"comics\", \"self-help\", \"cookbooks\"]},\n  {\"category\": \"Toys & Games\", \"subcategories\": [\"board games\", \"puzzles\", \"action figures\", \"educational toys\", \"electronic toys\", \"dolls\", \"outdoor play\", \"video games\"]},\n  {\"category\": \"Sports & Outdoors\", \"subcategories\": [\"fitness equipment\", \"camping gear\", \"cycling\", \"team sports gear\", \"yoga mats\", \"running shoes\", \"swimwear\", \"exercise accessories\"]},\n  {\"category\": \"Pet Supplies\", \"subcategories\": [\"dog food\", \"cat food\", \"aquatic supplies\", \"pet grooming tools\", \"pet toys\", \"pet beds\", \"bird supplies\", \"reptile accessories\"]},\n  {\"category\": \"Health & Household\", \"subcategories\": [\"vitamins\", \"supplements\", \"medical supplies\", \"cleaning products\", \"personal care essentials\", \"first aid kits\", \"nutrition bars\"]},\n  {\"category\": \"Tools & Home Improvement\", \"subcategories\": [\"power tools\", \"hand tools\", \"hardware\", \"paint supplies\", \"safety gear\", \"tool storage\", \"plumbing tools\", \"electrical tools\"]},\n  {\"category\": \"Industrial & Scientific\", \"subcategories\": [\"lab supplies\", \"safety equipment\", \"test & measurement devices\", \"industrial power supplies\", \"scientific instruments\"]},\n  {\"category\": \"Musical Instruments & Video Games\", \"subcategories\": [\"guitars\", \"keyboards\", \"drums\", \"audio interfaces\", \"video games\", \"game consoles\", \"PC software\"]},\n  {\"category\": \"Vehicles\", \"subcategories\": [\"cars\", \"bikes\", \"scooters\", \"trucks\", \"buses\", \"electric vehicles\", \"hybrid vehicles\", \"vans\", \"tractors\", \"rvs & campers\", \"commercial vehicles\", \"auto parts & accessories\"]}\n] \nYou will only use these categories and subcategories.\n\n\nðŸ”• Do NOT:\n- Say \"wait\" or \"hold on\"\n- Mention apps or platforms. Because platform is this app only.\n- Gathering options or display products list.\n- Searching, Filtering items, Displaying or Fetching Products.\n- Mention city or area.\n- Mention \"two quick questions 1. 2.\" and all these kind of things.\n\nâœ… Ending the Chat:\nDon't end the chat immediately until user says.\nIf the user says they are done or wants to end the conversation (even after just one message), summarize the conversation and return a JSON object with the product intent.\nYou can also end the chat if you think you have gathered the enough and necessary details or the chat is not attractive.\nâš ï¸ Important:\n-When the chat ends, respond ONLY with the raw plain JSON object.\n- In JSON object, \"description\" field must not contain like \"user not provided these or these things\".\n\nâœ³ï¸ JSON Format:\nYou MUST Return ONLY the raw JSON Plain Object when chat ends. Do NOT include any extra text, explanation, or formatting before or after.\n{\n  \"title\": Short, Focused product title of the entire conversation, \n    It can't be empty, whether user input very less details\n  \"description\": A concise summary **ONLY of the information provided by the user** during the chat. \n    It must be benefitâ€‘focused, in natural sentences ( max 100 words). \n    âš ï¸ Do NOT include details the user did not respond to.\n    âš ï¸ Do NOT mention any assistant questions, missing responses, or what was not answered.\n    âš ï¸ Do NOT say things like â€œuser was asked about...â€, â€œno details were providedâ€.\n  \"price\": Number // user provided or inferred, 0 if not mentioned\n  \"category\": \"main product category\", // Only From the categories array mentioned above\n  \"subcategory\": \"specific product type\",  // Only From the sub-categories array mentioned above\n  \"task_type\": either \"buy\" or \"sell\",  // based on userâ€™s intent, bydefault it will be \"buy\" if not confirmed\n  \"chat_ended\": true\n}\n`;\n \nconst conversationHistory = {};\n\nmodule.exports = {\n    getQueryInfo : async(req, res, next)=>{\n        try {           \n            const { user_query_text } = req.body;\n            if(!user_query_text){\n                throw new CustomError(400, 'Please send user query');\n            }\n            const user_id = req.user._id;\n\n            // const ttsResponse = await getOpenAIData(user_id, user_query_text);\n\n            // if(ttsResponse){\n            //   res.setHeader(\"Content-Type\", \"audio/mpeg\");\n            //   return ttsResponse.body.pipe(res);\n            // }\n\n            // // NO TTS â†’ TEXT/JSON RESPONSE MODE\n            // return res.status(200).json({\n            //     success: true,\n            //     data: null,\n            //     message: \"No TTS available for this response\"\n            // });\n\n            const data = await getOpenAIData(user_id, user_query_text);\n\n            // NO TTS â†’ TEXT/JSON RESPONSE MODE\n            return res.status(200).json({\n                success: true,\n                data,\n                message: \"Success\"\n            });\n        } catch (error) {\n            next(error);\n        }\n    }\n}\n\nasync function getOpenAIData(user_id, user_query_text){\n\n    const cleanedUserQuery = user_query_text.length > MAX_QUERY_LENGTH ? user_query_text.slice(0, MAX_QUERY_LENGTH) : user_query_text ;\n    \n    conversationHistory[user_id] = !conversationHistory[user_id]\n        ?   [ {role : 'user', content : cleanedUserQuery} ]\n        :   [\n                ...conversationHistory[user_id], \n                {role : 'user', content : cleanedUserQuery} \n            ] \n  \n\n    try {\n        //responses\n        // const chatCompletion = await openai.chat.completions.create({\n        //     model : process.env.OPEN_API_MODEL,\n        //     messages : [\n        //         { role: 'system', content: systemPrompt },\n        //         ...conversationHistory[user_id]\n        //     ]\n        // })\n        \n        // let AIResponse = chatCompletion.choices[0].message.content;\n\n        const response = await openai.responses.create({\n          // model: \"gpt-4o-realtime-preview-2024-12-17\",\n          model: \"gpt-4o-mini-tts\",\n          audio: {\n            voice: \"alloy\",\n            format: \"mp3\",\n          },\n          input: [\n            { role: 'system', content: systemPrompt },\n            ...conversationHistory[user_id]\n          ]\n        })\n        const content = response.output[0].content;\n\n        let assistantText;\n        let assistantAudio;\n        for(const item of content){\n          if(item.type == 'output_text'){\n            assistantText += item.text;\n          }\n          if (item.type === \"output_audio\") {\n            assistantAudio = item.audio_data;\n            // assistantAudio = Buffer.from(item.audio.data, \"base64\");\n          }\n          // else{\n          //   assistantAudio = item.audio;\n          // }\n        }\n        // console.log(AIResponse);\n\n        let data;\n\n        if(assistantText.includes('chat_ended')){\n            assistantText = JSON.parse(assistantText);\n            delete assistantText.chat_ended;\n            data = {\n                response : assistantText,\n                is_conversation_end : true\n            }\n\n            delete conversationHistory[user_id];\n        }else{\n            data = {\n                response : assistantText,\n                audio: assistantAudio,\n                is_conversation_end : false,\n            }\n\n            conversationHistory[user_id].push({\n                role : 'assistant',\n                content : assistantText\n            })\n        }\n\n        //send voice using api-response\n        return data;\n    } catch (error) {\n        console.log('Error : ', error);\n        throw error;\n    }\n}\n\n// async function getOpenAIData(user_id, user_query_text){\n\n//     const cleanedUserQuery = user_query_text.length > MAX_QUERY_LENGTH ? user_query_text.slice(0, MAX_QUERY_LENGTH) : user_query_text ;\n    \n//     conversationHistory[user_id] = !conversationHistory[user_id]\n//         ?   [ {role : 'user', content : cleanedUserQuery} ]\n//         :   [\n//                 ...conversationHistory[user_id], \n//                 {role : 'user', content : cleanedUserQuery} \n//             ] \n  \n\n//     try {\n//         //responses\n//         const chatCompletion = await openai.chat.completions.create({\n//             model : process.env.OPEN_API_MODEL,\n//             messages : [\n//                 { role: 'system', content: systemPrompt },\n//                 ...conversationHistory[user_id]\n//             ]\n//         })\n        \n//         let AIResponse = chatCompletion.choices[0].message.content;\n//         // console.log(AIResponse);\n\n//         let data;\n//         let ttsResponse;\n//         if(AIResponse.includes('chat_ended')){\n//             AIResponse = JSON.parse(AIResponse);\n//             delete AIResponse.chat_ended;\n//             data = {\n//                 response : AIResponse,\n//                 is_conversation_end : true\n//             }\n\n//             delete conversationHistory[user_id];\n//         }else{\n//             data = {\n//                 response : AIResponse,\n//                 is_conversation_end : false\n//             }\n\n//             // 3ï¸âƒ£ Create TTS audio stream and pipe directly to response\n//             ttsResponse = await openai.audio.speech.create({\n//               model: \"gpt-4o-mini-tts\",\n//               voice: \"alloy\",\n//               input: AIResponse,\n//               format: \"mp3\",\n//             });\n\n//             conversationHistory[user_id].push({\n//                 role : 'assistant',\n//                 content : AIResponse\n//             })\n//         }\n\n//         //send AI-response using socket\n//         const socketIO = getSocketIO();\n//         socketIO.to(user_id).emit(\"getMessage\", data);\n\n//         //send voice using api-response\n//         return ttsResponse;\n//     } catch (error) {\n//         console.log('Error : ', error);\n//         throw error;\n//     }\n// }\n\n// 109780621431\n\n","path":null,"size_bytes":15284,"size_tokens":null},"src/middlewares/isLoggedInMiddleware.js":{"content":"// const fs = require('fs').promises;\n// const path = require('path');\n\nconst { CustomError } = require(\"../utils/customError\");\nconst { decodeToken } = require(\"../utils/helperFunctions\");\nconst userModel = require('../models/users');\n\n// const logPath = path.join(__dirname, 'error_log_file.log');\n\nconst isLoggedInMiddleware = async(req, res, next) =>{\n    try{\n        const authorization = req.headers?.authorization;\n        if(!authorization){\n            throw new CustomError(401, 'No token found', 'isLoggedInMiddleware');\n        }\n\n        const accessToken = authorization.split(' ')[1];\n        if(!accessToken){\n            throw new CustomError(401, 'No token found', 'isLoggedInMiddleware');\n        }\n        if(accessToken == 'undefined'){\n            throw new CustomError(401, `Received undefined, Incorrect token`, 'isLoggedInMiddleware');\n        }\n        \n        // console.log(accessToken, '------------accesstoken');\n\n        const decodedToken = decodeToken(accessToken);\n        if(typeof(decodedToken) == 'object' && decodedToken.isError){\n            throw new CustomError(401, `${accessToken} received, Incorrect token`, 'isLoggedInMiddleware');\n        }\n        if(decodedToken.access_type != 'logged_in'){\n            throw new CustomError(401, 'No token found', 'isLoggedInMiddleware');\n        }\n        \n        const user = await userModel.findOne({_id : decodedToken._id});\n        if(!user){\n            throw new CustomError(401, 'User not exists', 'isLoggedInMiddleware');\n        }\n\n        req.user = user;\n        next();\n    }catch(error){\n        console.log(error);\n        next(error)\n    }\n}\n\nmodule.exports = isLoggedInMiddleware","path":null,"size_bytes":1682,"size_tokens":null},"index.js":{"content":"require('dotenv').config();\nconst express=require('express');\nconst app=express();\nconst http = require('http');\nconst mongoose = require('mongoose');\nconst cors = require('cors');\nconst fileUpload = require('express-fileupload');\nconst path = require('path');\nconst cloudinary = require('cloudinary').v2;\nconst jwt = require('jsonwebtoken');\nconst crypto = require('crypto');\n\nconst { errorMiddleware } = require('./src/middlewares/errorMiddleware');\nconst { initializeSocketServer } = require('./src/config/socket/socket');\nconst { queryObjects } = require('v8');\nconst { SocketAddress } = require('net');\nconst { RoomRecordingPage } = require('twilio/lib/rest/video/v1/room/roomRecording');\n\napp.use(cors('*'));\napp.use(express.json());\napp.use(express.urlencoded({extended:true}));\n\n// app.use(express.static(path.join(__dirname, 'src', 'public')))\n// app.use(fileUpload());\n// Middleware\napp.use(fileUpload({\n  useTempFiles: true,\n  tempFileDir: '/tmp/', // required for cloudinary file handling\n}));\n\napp.get('/health',(req,res)=>{\n    res.status(200).send({success:true});\n})\napp.use('/webservice/api', require('./src/routes'));\napp.use(errorMiddleware);\n\nconst server = http.createServer(app);\n\nmongoose.connect(process.env.MONGO_CONNECTION_STRING)\n.then(()=>{\n    console.log('MongoDB connected');  \n    \n    server.listen(process.env.PORT, ()=>{\n        console.log('server is running at port: ', process.env.PORT);\n\n        //initializing socket\n        initializeSocketServer(server);\n\n        //running cron\n        require('./src/utils/cron');\n    })\n})\n.catch(error=>{\n    console.log('Error in MongoDB connection ', error);\n})\n\n//=================to generate jwt tokens\n// const secret = crypto.randomBytes(64).toString(\"hex\"); // 512-bit secret\n// console.log(jwt.sign({name:'mayank'}, secret, {expiresIn: '30d'}));\n\n// const helperFunctions = require('./src/utils/helperFunctions');\n// helperFunctions.sendOTP('+918000727389', '12111');\n\n\n\n\n// 1. Install Winston:\n// npm install winston\n\n// 2. Basic Setup:\n// // logger.js\n// const winston = require('winston');\n\n// const logger = winston.createLogger({\n//   level: 'info', // 'error', 'warn', 'info', 'debug'\n//   format: winston.format.combine(\n//     winston.format.timestamp(),\n//     winston.format.printf(({ timestamp, level, message }) => {\n//       return `[${timestamp}] ${level.toUpperCase()}: ${message}`;\n//     })\n//   ),\n//   transports: [\n//     new winston.transports.Console(), // Log to console\n//     new winston.transports.File({ filename: 'error.log', level: 'error' }) // Save errors to file\n//   ]\n// });\n\n// module.exports = logger;\n\n// 3. Use It in Your App:\n// const logger = require('./logger');\n\n// // Example error logging\n// try {\n//   throw new Error('Something went wrong');\n// } catch (err) {\n//   logger.error(`Caught error: ${err.message}`);\n// }\n\n// ðŸ“„ You can log other levels too:\n// logger.info('Server started on port 4000');\n// logger.warn('Something might be off');\n// logger.debug('Debugging details');\n\n// ðŸ› ï¸ Tip: Centralized Error Middleware (for Express apps)\n// app.use((err, req, res, next) => {\n//   logger.error(`${req.method} ${req.url} - ${err.message}`);\n//   res.status(500).json({ error: 'Internal Server Error' });\n// });\n\n\n//Streaming audio and text\n// Frontend will hit the regular api to send the user query\n// Backend will send the data in chunks to frontend using Sockets\n\n// User will join a room using user_id before start the chatting \n\n// =====> Socket events\n// 1.  \"createRoom\" to join a room and paas user_id inside roomId\n// 2. \"audio_chunk\" you will get {audio_base64} chunk until the streaming completes (means u will get data in packets)\n// 3. \"text_chunk\" you will get {text} chunk \n// 4. \"text_message\" you will get full text at the end\n// 5. \"chat_ended\" when chat will be ended then you will get a json in this","path":null,"size_bytes":3861,"size_tokens":null},"AI-controlller.backup.js":{"content":"const express=require('express');\nconst router = express.Router();\nconst { OpenAI } = require('openai');\nconst axios = require('axios');\nconst WebSocket = require('ws');\nconst wav = require(\"node-wav\");\nconst fs = require('fs');\n\nconst { CustomError } = require('../../../utils/customError');\nconst { getSocketIO } = require('../../../config/socket/socket_service');\nlet socketIo;\n\nconst openai = new OpenAI({ apiKey : process.env.OPEN_API_KEY });\n\n\nconst categories = [\n  {\n    \"category\": \"Fashion\",\n    \"subcategories\": [\n      \"jeans\", \"shirts\", \"t-shirts\", \"polo shirts\", \"shorts\",\n      \"jackets\", \"sweatshirts\", \"hoodies\", \"skirts\", \"dresses\",\n      \"handbags\", \"watches\", \"shoes\", \"socks\", \"underwear\",\n      \"belts\", \"scarves\", \"sunglasses\"\n    ]\n  },\n  {\n    \"category\": \"Electronics\",\n    \"subcategories\": [\n      \"mobile phones\", \"laptops\", \"cameras\", \"headphones\",\n      \"smartwatches\", \"smart speakers\", \"televisions\", \"tablets\",\n      \"wireless earbuds\", \"routers\", \"external hard drives\",\n      \"printers\", \"monitors\", \"game consoles\"\n    ]\n  },\n  {\n    \"category\": \"Home & Kitchen\",\n    \"subcategories\": [\n      \"cookware\", \"bedding\", \"sofas\", \"dining tables\",\n      \"small kitchen appliances\", \"vacuum cleaners\", \"wall art\",\n      \"bath towels\", \"kitchen utensils\", \"coffee makers\",\n      \"mattresses\", \"desk chairs\"\n    ]\n  },\n  {\n    \"category\": \"Beauty & Personal Care\",\n    \"subcategories\": [\n      \"skincare\", \"lipstick\", \"perfume\", \"shampoo\",\n      \"conditioner\", \"body lotion\", \"oral care\", \"makeup brushes\",\n      \"hair coloring\", \"face serums\", \"facial cleansers\"\n    ]\n  },\n  {\n    \"category\": \"Books\",\n    \"subcategories\": [\n      \"fiction\", \"non-fiction\", \"childrenâ€™s books\", \"textbooks\",\n      \"audiobooks\", \"ebooks\", \"comics\", \"self-help\", \"cookbooks\"\n    ]\n  },\n  {\n    \"category\": \"Toys & Games\",\n    \"subcategories\": [\n      \"board games\", \"puzzles\", \"action figures\", \"educational toys\",\n      \"electronic toys\", \"dolls\", \"outdoor play\", \"video games\"\n    ]\n  },\n  {\n    \"category\": \"Sports & Outdoors\",\n    \"subcategories\": [\n      \"fitness equipment\", \"camping gear\", \"cycling\",\n      \"team sports gear\", \"yoga mats\", \"running shoes\",\n      \"swimwear\", \"exercise accessories\"\n    ]\n  },\n  {\n    \"category\": \"Pet Supplies\",\n    \"subcategories\": [\n      \"dog food\", \"cat food\", \"aquatic supplies\", \"pet grooming tools\",\n      \"pet toys\", \"pet beds\", \"bird supplies\", \"reptile accessories\"\n    ]\n  },\n  {\n    \"category\": \"Health & Household\",\n    \"subcategories\": [\n      \"vitamins\", \"supplements\", \"medical supplies\", \"cleaning products\",\n      \"personal care essentials\", \"first aid kits\", \"nutrition bars\"\n    ]\n  },\n  {\n    \"category\": \"Tools & Home Improvement\",\n    \"subcategories\": [\n      \"power tools\", \"hand tools\", \"hardware\", \"paint supplies\",\n      \"safety gear\", \"tool storage\", \"plumbing tools\", \"electrical tools\"\n    ]\n  },\n  {\n    \"category\": \"Industrial & Scientific\",\n    \"subcategories\": [\n      \"lab supplies\", \"safety equipment\", \"test & measurement devices\",\n      \"industrial power supplies\", \"scientific instruments\"\n    ]\n  },\n  {\n    \"category\": \"Musical Instruments & Video Games\",\n    \"subcategories\": [\n      \"guitars\", \"keyboards\", \"drums\", \"audio interfaces\",\n      \"video games\", \"game consoles\", \"PC software\"\n    ]\n  }\n]\n\nconst MAX_QUERY_LENGTH = 500; // Adjust based on model's token limits\n\nconst systemPrompt = `You are a focused sales assistant helping users buy or sell products.\n\nðŸŽ¯ Your job:\n- Understand the user's intent (buy or sell).\n- Ask clear, non-repeating follow-up questions about the product (model, brand, condition, price, etc.).\n- These Follow-up questions must be in some priority not random order.\n  1. Main Goal â†’ First, ask about the key product needs such as model, brand, condition (new/used), and price range.\n  2. Specific Details â†’ Next, ask about important preferences like features, size, color, or style.\n  Also don't ask all of these in single go.\n- Only ask 1-2 follow-up questions at a time not multiple questions, follow-up question should not be long.\n- If the user says single-word-input or short sentence then also ask good follow-up question for that.\n- You can ask upto 5-6 follow-up Questions.\n- Stay on product-related topics only, If the user asks personal or off-topic questions then Remind them \n  you're a sales assistant within this app and guide back to the product.\n- If the user asks about product availability or show me products, Then reply:\n  \"I'm currently gathering all the necessary product details. Once I have everything, I can show you the best matching products\", \n  And guide back to the product.\n\n\nCategories and Subcategories for any Product must be:\n[\n  {\"category\": \"Fashion\", \"subcategories\": [\"jeans\", \"shirts\", \"t-shirts\", \"polo shirts\", \"shorts\", \"jackets\", \"sweatshirts\", \"hoodies\", \"skirts\", \"dresses\", \"handbags\", \"watches\", \"shoes\", \"socks\", \"underwear\", \"belts\", \"scarves\", \"sunglasses\"]},\n  {\"category\": \"Electronics\", \"subcategories\": [\"mobile phones\", \"laptops\", \"cameras\", \"headphones\", \"smartwatches\", \"smart speakers\", \"televisions\", \"tablets\", \"wireless earbuds\", \"routers\", \"external hard drives\", \"printers\", \"monitors\", \"game consoles\"]},\n  {\"category\": \"Home & Kitchen\", \"subcategories\": [\"cookware\", \"bedding\", \"sofas\", \"dining tables\", \"small kitchen appliances\", \"vacuum cleaners\", \"wall art\", \"bath towels\", \"kitchen utensils\", \"coffee makers\", \"mattresses\", \"desk chairs\"]},\n  {\"category\": \"Beauty & Personal Care\", \"subcategories\": [\"skincare\", \"lipstick\", \"perfume\", \"shampoo\", \"conditioner\", \"body lotion\", \"oral care\", \"makeup brushes\", \"hair coloring\", \"face serums\", \"facial cleansers\"]},\n  {\"category\": \"Books\", \"subcategories\": [\"fiction\", \"non-fiction\", \"childrenâ€™s books\", \"textbooks\", \"audiobooks\", \"ebooks\", \"comics\", \"self-help\", \"cookbooks\"]},\n  {\"category\": \"Toys & Games\", \"subcategories\": [\"board games\", \"puzzles\", \"action figures\", \"educational toys\", \"electronic toys\", \"dolls\", \"outdoor play\", \"video games\"]},\n  {\"category\": \"Sports & Outdoors\", \"subcategories\": [\"fitness equipment\", \"camping gear\", \"cycling\", \"team sports gear\", \"yoga mats\", \"running shoes\", \"swimwear\", \"exercise accessories\"]},\n  {\"category\": \"Pet Supplies\", \"subcategories\": [\"dog food\", \"cat food\", \"aquatic supplies\", \"pet grooming tools\", \"pet toys\", \"pet beds\", \"bird supplies\", \"reptile accessories\"]},\n  {\"category\": \"Health & Household\", \"subcategories\": [\"vitamins\", \"supplements\", \"medical supplies\", \"cleaning products\", \"personal care essentials\", \"first aid kits\", \"nutrition bars\"]},\n  {\"category\": \"Tools & Home Improvement\", \"subcategories\": [\"power tools\", \"hand tools\", \"hardware\", \"paint supplies\", \"safety gear\", \"tool storage\", \"plumbing tools\", \"electrical tools\"]},\n  {\"category\": \"Industrial & Scientific\", \"subcategories\": [\"lab supplies\", \"safety equipment\", \"test & measurement devices\", \"industrial power supplies\", \"scientific instruments\"]},\n  {\"category\": \"Musical Instruments & Video Games\", \"subcategories\": [\"guitars\", \"keyboards\", \"drums\", \"audio interfaces\", \"video games\", \"game consoles\", \"PC software\"]},\n  {\"category\": \"Vehicles\", \"subcategories\": [\"cars\", \"bikes\", \"scooters\", \"trucks\", \"buses\", \"electric vehicles\", \"hybrid vehicles\", \"vans\", \"tractors\", \"rvs & campers\", \"commercial vehicles\", \"auto parts & accessories\"]}\n] \nYou will only use these categories and subcategories.\n\n\nðŸ”• Do NOT:\n- Say \"wait\" or \"hold on\"\n- Mention apps or platforms, online or offline. Because platform is this app only.\n- Gathering options or display products list.\n- Searching, Filtering items, Displaying or Fetching Products.\n- Mention city or area.\n- Mention \"two quick questions 1. 2.\" and all these kind of things.\n`;\n\nconst chatEndDetectionSystemPrompt = `\nYou are an AI that detects if a user message ends a conversation. \nMust Reply ONLY as JSON: {\"chat_ended\": true} or {\"chat_ended\": false}. \nDo not add any extra text.\n`;\n\nconst chatEndedSummarySystemPrompt = `\nYou are a focused sales assistant helping users buy or sell Products.\nYour goal is to analyze and Summarize the chat conversation.\n\nCategories and Subcategories for any Product must be:\n[\n  {\"category\": \"Fashion\", \"subcategories\": [\"jeans\", \"shirts\", \"t-shirts\", \"polo shirts\", \"shorts\", \"jackets\", \"sweatshirts\", \"hoodies\", \"skirts\", \"dresses\", \"handbags\", \"watches\", \"shoes\", \"socks\", \"underwear\", \"belts\", \"scarves\", \"sunglasses\"]},\n  {\"category\": \"Electronics\", \"subcategories\": [\"mobile phones\", \"laptops\", \"cameras\", \"headphones\", \"smartwatches\", \"smart speakers\", \"televisions\", \"tablets\", \"wireless earbuds\", \"routers\", \"external hard drives\", \"printers\", \"monitors\", \"game consoles\"]},\n  {\"category\": \"Home & Kitchen\", \"subcategories\": [\"cookware\", \"bedding\", \"sofas\", \"dining tables\", \"small kitchen appliances\", \"vacuum cleaners\", \"wall art\", \"bath towels\", \"kitchen utensils\", \"coffee makers\", \"mattresses\", \"desk chairs\"]},\n  {\"category\": \"Beauty & Personal Care\", \"subcategories\": [\"skincare\", \"lipstick\", \"perfume\", \"shampoo\", \"conditioner\", \"body lotion\", \"oral care\", \"makeup brushes\", \"hair coloring\", \"face serums\", \"facial cleansers\"]},\n  {\"category\": \"Books\", \"subcategories\": [\"fiction\", \"non-fiction\", \"childrenâ€™s books\", \"textbooks\", \"audiobooks\", \"ebooks\", \"comics\", \"self-help\", \"cookbooks\"]},\n  {\"category\": \"Toys & Games\", \"subcategories\": [\"board games\", \"puzzles\", \"action figures\", \"educational toys\", \"electronic toys\", \"dolls\", \"outdoor play\", \"video games\"]},\n  {\"category\": \"Sports & Outdoors\", \"subcategories\": [\"fitness equipment\", \"camping gear\", \"cycling\", \"team sports gear\", \"yoga mats\", \"running shoes\", \"swimwear\", \"exercise accessories\"]},\n  {\"category\": \"Pet Supplies\", \"subcategories\": [\"dog food\", \"cat food\", \"aquatic supplies\", \"pet grooming tools\", \"pet toys\", \"pet beds\", \"bird supplies\", \"reptile accessories\"]},\n  {\"category\": \"Health & Household\", \"subcategories\": [\"vitamins\", \"supplements\", \"medical supplies\", \"cleaning products\", \"personal care essentials\", \"first aid kits\", \"nutrition bars\"]},\n  {\"category\": \"Tools & Home Improvement\", \"subcategories\": [\"power tools\", \"hand tools\", \"hardware\", \"paint supplies\", \"safety gear\", \"tool storage\", \"plumbing tools\", \"electrical tools\"]},\n  {\"category\": \"Industrial & Scientific\", \"subcategories\": [\"lab supplies\", \"safety equipment\", \"test & measurement devices\", \"industrial power supplies\", \"scientific instruments\"]},\n  {\"category\": \"Musical Instruments & Video Games\", \"subcategories\": [\"guitars\", \"keyboards\", \"drums\", \"audio interfaces\", \"video games\", \"game consoles\", \"PC software\"]},\n  {\"category\": \"Vehicles\", \"subcategories\": [\"cars\", \"bikes\", \"scooters\", \"trucks\", \"buses\", \"electric vehicles\", \"hybrid vehicles\", \"vans\", \"tractors\", \"rvs & campers\", \"commercial vehicles\", \"auto parts & accessories\"]}\n] \nYou will only use these categories and subcategories.\n\nSummarize the chat conversation with the product intent.\nRespond ONLY with the raw plain JSON object.\n\nâœ³ï¸ JSON Format:\nYou MUST Return ONLY the raw JSON Plain Object. Do NOT include any extra text, explanation, or formatting before or after.\n{\n  \"title\": \"\",\n  \"description\": \"\",\n  \"price\": \"\",\n  \"category\": \"\",\n  \"subcategory\": \"\",\n  \"task_type\": \"\"\n}\n\nJSON Fields Explaination\n{\n  \"title\": Short, Focused product title of the entire conversation, \n    It can't be empty, whether user input very less details\n  \"description\": A concise summary **ONLY of the information provided by the user** during the chat. \n    It must be benefitâ€‘focused, in natural sentences ( max 100 words). \n    âš ï¸ Do NOT include details the user did not respond to.\n    âš ï¸ Do NOT mention any assistant questions, missing responses, or what was not answered.\n    âš ï¸ Do NOT say things like â€œuser was asked about...â€, â€œno details were providedâ€.\n  \"price\": Number // user provided or inferred, 0 if not mentioned\n  \"category\": \"main product category\", // Only From the categories array mentioned above\n  \"subcategory\": \"specific product type\",  // Only From the sub-categories array mentioned above\n  \"task_type\": either \"buy\" or \"sell\",  // based on userâ€™s intent whether he wants to \"buy\" or \"sell\" ,\n    bydefault it will be \"buy\" if not confirmed\n}`;\n \nconst conversationHistory = {};\nconst streamingHistory = {};\nconst realTimeSessions = {};\nconst webSocketInstances = {};\n\nlet audioChunks = [];\n\nmodule.exports = {\n    chatAssistant : async(req, res, next)=>{\n        try {           \n            const { user_query_text } = req.body;\n            if(!user_query_text){\n                throw new CustomError(400, 'Please send user query');\n            }\n            const user_id = req.user._id;\n            socketIo = getSocketIO();\n\n            if(await isUserWantsToEndChat(user_query_text)){\n              const chatEndedSummmary = await getChatEndedSummary(user_id);\n\n              //clearing chat history\n              if(conversationHistory[user_id]){  \n                conversationHistory[user_id] = null;\n              }\n\n              //clearing streaming history\n              if(streamingHistory[user_id]){  \n                streamingHistory[user_id] = null;\n              }\n\n              //closing websocket\n              closeWS(user_id);\n              realTimeSessions[user_id] = null;\n\n              //sending response to user\n              socketIo.to(user_id.toString()).emit('chat_ended', chatEndedSummmary);\n            }\n            else{\n              salesAssistant(user_id, user_query_text)\n            }\n\n            return res.status(200).json({\n                success: true,\n                message: \"Success\"\n            });\n        } catch (error) {\n            next(error);\n        }\n    }\n}\n\nasync function isUserWantsToEndChat(message){\n  try {\n    const completion = await openai.chat.completions.create({\n      model: \"gpt-4o-mini\",\n      messages: [\n        { role: \"system\", content: chatEndDetectionSystemPrompt },\n        { role: \"user\", content: `Message: \"${message}\"` }\n      ],\n    });\n\n    const responseText = completion.choices[0].message.content;\n    const parsed = JSON.parse(responseText);\n    console.log(parsed, '========end detection');\n    return parsed.chat_ended;\n  } catch (err) {\n    console.error(\"âŒ Failed to detect chat-end message:\");\n    throw err;\n  }\n}\n\nasync function getChatEndedSummary(user_id){\n   try {\n\n    if(!conversationHistory[user_id]){\n      return {\n        \"title\": \"\",\n        \"description\": \"\",\n        \"price\": \"\",\n        \"category\": \"\",\n        \"subcategory\": \"\",\n        \"task_type\": \"\"\n      }\n    }\n\n    const completion = await openai.chat.completions.create({\n      model: \"gpt-5-mini\",\n      messages: [\n        { role: \"system\", content: chatEndedSummarySystemPrompt },\n        ...conversationHistory[user_id]\n      ],\n    });\n\n    const responseText = completion.choices[0].message.content;\n    const parsed = JSON.parse(responseText);\n\n    return parsed;\n  } catch (err) {\n    console.error(\"âŒ Failed to get chat ended summary:\");\n    throw err;\n  }\n}\n\nasync function salesAssistant(user_id, message) {\n  message = message.length > MAX_QUERY_LENGTH ? message.slice(0, MAX_QUERY_LENGTH) : message ;\n    \n  conversationHistory[user_id] = !conversationHistory[user_id]\n      ?   [ {role : 'user', content : message} ]\n      :   [\n              ...conversationHistory[user_id], \n              {role : 'user', content : message} \n          ]\n\n  streamingHistory[user_id] = !streamingHistory[user_id]\n      ?   \n        [{\n          type: \"message\",\n          role: \"user\",\n          content: [{type: \"input_text\",text: message}]\n        }]\n      :\n        [\n          ...streamingHistory[user_id], \n          {\n            type: \"message\",\n            role: \"user\",\n            content: [{type: \"input_text\",text: message}]\n          }\n        ] \n\n\n  if(!realTimeSessions[user_id]){\n    realTimeSessions[user_id] = await createRealtimeSession();\n  }\n  const wsUrl = realTimeSessions[user_id];\n\n  let ws;\n  if(!webSocketInstances[user_id] || webSocketInstances[user_id].readyState != 1){    \n\n    closeWS(user_id);\n\n    ws = new WebSocket(wsUrl, {\n      headers: { Authorization: `Bearer ${process.env.OPEN_API_KEY}` }\n    });\n\n    webSocketInstances[user_id] = ws;\n\n    if (!ws._listenersAttached) {\n\n      // attach listeners ONCE\n      ws.on(\"open\", () => {\n        console.log(\"===== WebSocket Connected\");\n\n        ws.send(JSON.stringify({\n          type: \"response.create\",\n          response: {\n            instructions: systemPrompt\n          }\n        }));\n\n      });\n\n      ws.on(\"message\", (data) => handleMessage(user_id, data));\n      ws.on(\"close\", () => closeWS(user_id));\n      ws.on(\"error\", () => closeWS(user_id));\n\n      ws._listenersAttached = true;\n    }\n\n  }else{\n    ws = webSocketInstances[user_id];\n  }\n  \n  console.log(ws.readyState, '==========ws');\n\n  console.log(streamingHistory[user_id]);\n\n  const webSocketPayload = {\n    type: \"response.create\",\n    response: {\n      instructions: systemPrompt,\n      input: [\n          // {\n          //   type: \"message\",\n          //   role: \"system\",\n          //   content: [\n          //     {\n          //       type: \"input_text\",\n          //       text: systemPrompt\n          //     }\n          //   ]\n          // },\n          ...streamingHistory[user_id], \n          // {\n          //   type: \"message\",\n          //   role: \"user\",\n          //   content: [\n          //     {\n          //       type: \"input_text\",\n          //       text: message\n          //     }\n          //   ]\n          // },\n      ],\n      output_modalities: [\"audio\"]\n    }\n  }\n\n  if(ws.readyState == 0){\n    ws.once(\"open\", () => {\n      console.log('=====> OpenAI Websocket Connected');\n      ws.send(JSON.stringify(webSocketPayload));\n    });\n  }\n  else{\n    ws.send(JSON.stringify(webSocketPayload));\n  }\n \n}\n\n\n\n\n//Incoming websocket event handlers\n// function closeWS(user_id) {\n//   const ws = webSocketInstances[user_id];\n//   if (ws) {\n//     try {\n//       ws.removeAllListeners();  // ðŸš¨ Prevent memory leak\n//       ws.terminate();           // ðŸš¨ Hard kill immediately\n//     } catch (e) {}\n//   }\n\n//   webSocketInstances[user_id] = null;\n//   // realTimeSessions[user_id] = null;\n// }\nfunction closeWS(user_id) {\n  const ws = webSocketInstances[user_id];\n  if (ws) {\n    try { ws.removeAllListeners(); } catch (e) {}\n    try { ws.terminate(); } catch (e) {}\n    ws._listenersAttached = false;\n  }\n\n  webSocketInstances[user_id] = null;\n}\nfunction handleMessage(user_id, data) {\n  const msg = JSON.parse(data.toString());\n\n  // AUDIO DELTAS\n  if (msg.type === \"response.output_audio.delta\") {\n      console.log('==========audio chunk');\n\n      const base64 = msg.delta;\n      const audioBuffer = Buffer.from(base64, \"base64\");\n\n      // audioChunks.push(audioBuffer);\n\n      //sending audio-chunk to user\n      socketIo.to(user_id.toString()).emit('audio_chunk', {audio_base64: base64});\n  }\n  else if (msg.type === \"response.output_audio_transcript.delta\") {\n      console.log('=======text chunk', msg.delta);\n\n      //sending text-chunk to user\n      socketIo.to(user_id.toString()).emit('text_chunk', {text: msg.delta});\n  }\n  else if(msg.type === 'response.content_part.done'){\n      const message = msg.part.transcript;\n\n      //sending full-text message to user\n      socketIo.to(user_id.toString()).emit('text_message', {text: message});\n\n      conversationHistory[user_id] = [\n          ...conversationHistory[user_id], \n          {role : 'assistant', content : message} \n      ]\n\n      // streamingHistory[user_id] =  [\n      //   ...streamingHistory[user_id], \n      //   {\n      //     type: \"message\",\n      //     role: \"assistant\",\n      //     content: [{type: \"input_text\",text: message}]\n      //   }\n      // ] \n  }\n  else if (msg.type === \"response.done\") {\n    console.log(\"Done.\");\n    // playAudioChunks();\n  }\n  \n}\n\n//helping functions\nasync function createRealtimeSession() {\n  try {\n    const session = await axios.post(\n      \"https://api.openai.com/v1/realtime/sessions\",\n      {\n        model: \"gpt-4o-realtime-preview-2024-12-17\",\n        modalities: [\"text\", \"audio\"],\n        voice: \"alloy\", //'alloy', 'ash', 'ballad', 'coral', 'echo', 'sage', 'shimmer', 'verse', 'marin', and 'cedar'.\n        // the correct key now\n        output_audio_format: \"pcm16\"\n      },\n      {\n        headers: {\n          Authorization: `Bearer ${process.env.OPEN_API_KEY}`,\n          \"Content-Type\": \"application/json\",\n        }\n      }\n    );\n\n    const clientSecret = session.data.client_secret.value;\n\n    const wsUrl =\n      `wss://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-12-17` +\n      `&client_secret=${clientSecret}`;\n\n    console.log(\"WS:\", wsUrl);\n    return wsUrl;\n  } catch (err) {\n    console.log(\"Session error:\", err.response?.data || err);\n    throw err;\n  }\n}\nfunction playAudioChunks() {\n  const pcm = Buffer.concat(audioChunks);\n\n  // Convert PCM16 â†’ Float32 for high quality WAV\n  const sampleCount = pcm.length / 2;\n  const float32 = new Float32Array(sampleCount);\n\n  for (let i = 0; i < sampleCount; i++) {\n    float32[i] = pcm.readInt16LE(i * 2) / 32768;\n  }\n\n  const wavData = wav.encode([float32], {\n    sampleRate: 24000,\n    float: true,\n    bitDepth: 32,\n  });\n\n  fs.writeFileSync(\"output.wav\", wavData);\n  console.log(\"ðŸ”Š Saved clean WAV â†’ output.wav\");\n}\n\n// 109780621431\n\n","path":null,"size_bytes":21367,"size_tokens":null},"src/modules/v1/products/controller.js":{"content":"const { v4: uuidv4 } = require('uuid');\nconst path = require('path');\nconst cloudinary = require('cloudinary').v2;\nconst { OpenAI } = require('openai');\nconst axios = require('axios');\nconst mongoose = require('mongoose');\n\nconst ProductModel = require('../../../models/products.js');\nconst UserModel = require('../../../models/users.js');\nconst { CustomError } = require('../../../utils/customError.js');\nconst { getLocationUsingCoordinates, getDistanceBetweenCoordinates, getCityNameUsingLocation } = require('../../../utils/helperFunctions.js');\n\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\n  api_key: process.env.CLOUDINARY_API_KEY,\n  api_secret: process.env.CLOUDINARY_API_SECRET,\n});\n\n// Initialize OPEN-AI with API key\nconst openai = new OpenAI({ apiKey : process.env.OPEN_API_KEY });\n\n\n//-----------common functions\n// const resp = voyageAIClient.multimodalEmbed({\n//   inputs: [\n//     {\n//       content: [\n//         {\n//           type: \"text\",\n//           text: \"Title: shoes. Description: shoes. Category: fashion. Subcategory: shoes\"\n//         }\n//       ]\n//     }\n//   ],\n//   model: \"voyage-multimodal-3\",\n//   input_type: \"query\"\n// });\n\n//1536 using openAI\nasync function getEmbedding1536(text) {\n  const response = await openai.embeddings.create({\n    model: \"text-embedding-3-small\",\n    input: text,\n    dimensions: 1536\n  });\n\n  // response.data is an array, we take the first embedding\n  return response.data[0].embedding;\n}\n//It Gives 1024 dimensions using voyage model ( text + images both)\nasync function embedMultimodal(text, imageUrlsList) {\n    const content = [];\n    if(text){\n        content.push({ type: \"text\", text});\n    }\n    if(imageUrlsList?.length){\n        imageUrlsList.forEach(url => content.push({ type: \"image_url\", image_url: url }))\n    }\n\n    const payload = {\n        inputs : [{content}],\n        model: 'voyage-multimodal-3',  // exactly as this string\n        input_type: 'query'\n    };\n    \n    const response = await axios.post(\n      'https://api.voyageai.com/v1/multimodalembeddings',\n      payload,\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${process.env.VOYAGE_API_KEY}`\n        }\n      }\n    );\n\n    return response.data.data[0].embedding; // 1024â€‘dim embedding vector\n}\n\nfunction getDBOldImages(dbImages, restImageURLs){\n\n    const dbOldImages = [];\n    const dbOldImagesToDelete = [];\n    \n    const restImagesObj ={};\n    restImageURLs.forEach(imgURL =>{\n        const publicIdAndImgFormat = imgURL.replace(`${process.env.CLOUDINARY_BASE_URL}/`, '');\n        restImagesObj[publicIdAndImgFormat] = 1;\n    })\n\n    dbImages.forEach(dbImage =>{\n        const publicIdAndImgFormat = `${dbImage.public_id}.${dbImage.image_format}`;\n        if(restImagesObj[publicIdAndImgFormat]){\n            dbOldImages.push(dbImage);\n        }else{\n            dbOldImagesToDelete.push(dbImage);\n        }\n    })\n\n    return {dbOldImages, dbOldImagesToDelete};\n}\nasync function deleteImagesFromCloudinary(dbImages){\n    const dbImagesPromises = dbImages.map(dbImage => cloudinary.uploader.destroy(dbImage.public_id));\n    await Promise.all(dbImagesPromises); \n}\n\nconst deleteAllProducts=async ()=>{\n    await ProductModel.deleteMany({});\n}\nconst deleteAllUsers=async ()=>{\n    await UserModel.deleteMany({});\n}\n\nconst categories = [\n  {\n    \"category\": \"Fashion\",\n    \"subcategories\": [\n      \"jeans\", \"shirts\", \"t-shirts\", \"polo shirts\", \"shorts\",\n      \"jackets\", \"sweatshirts\", \"hoodies\", \"skirts\", \"dresses\",\n      \"handbags\", \"watches\", \"shoes\", \"socks\", \"underwear\",\n      \"belts\", \"scarves\", \"sunglasses\"\n    ]\n  },\n  {\n    \"category\": \"Electronics\",\n    \"subcategories\": [\n      \"mobile phones\", \"laptops\", \"cameras\", \"headphones\",\n      \"smartwatches\", \"smart speakers\", \"televisions\", \"tablets\",\n      \"wireless earbuds\", \"routers\", \"external hard drives\",\n      \"printers\", \"monitors\", \"game consoles\"\n    ]\n  },\n  {\n    \"category\": \"Home & Kitchen\",\n    \"subcategories\": [\n      \"cookware\", \"bedding\", \"sofas\", \"dining tables\",\n      \"small kitchen appliances\", \"vacuum cleaners\", \"wall art\",\n      \"bath towels\", \"kitchen utensils\", \"coffee makers\",\n      \"mattresses\", \"desk chairs\"\n    ]\n  },\n  {\n    \"category\": \"Beauty & Personal Care\",\n    \"subcategories\": [\n      \"skincare\", \"lipstick\", \"perfume\", \"shampoo\",\n      \"conditioner\", \"body lotion\", \"oral care\", \"makeup brushes\",\n      \"hair coloring\", \"face serums\", \"facial cleansers\"\n    ]\n  },\n  {\n    \"category\": \"Books\",\n    \"subcategories\": [\n      \"fiction\", \"non-fiction\", \"childrenâ€™s books\", \"textbooks\",\n      \"audiobooks\", \"ebooks\", \"comics\", \"self-help\", \"cookbooks\"\n    ]\n  },\n  {\n    \"category\": \"Toys & Games\",\n    \"subcategories\": [\n      \"board games\", \"puzzles\", \"action figures\", \"educational toys\",\n      \"electronic toys\", \"dolls\", \"outdoor play\", \"video games\"\n    ]\n  },\n  {\n    \"category\": \"Sports & Outdoors\",\n    \"subcategories\": [\n      \"fitness equipment\", \"camping gear\", \"cycling\",\n      \"team sports gear\", \"yoga mats\", \"running shoes\",\n      \"swimwear\", \"exercise accessories\"\n    ]\n  },\n  {\n    \"category\": \"Pet Supplies\",\n    \"subcategories\": [\n      \"dog food\", \"cat food\", \"aquatic supplies\", \"pet grooming tools\",\n      \"pet toys\", \"pet beds\", \"bird supplies\", \"reptile accessories\"\n    ]\n  },\n  {\n    \"category\": \"Health & Household\",\n    \"subcategories\": [\n      \"vitamins\", \"supplements\", \"medical supplies\", \"cleaning products\",\n      \"personal care essentials\", \"first aid kits\", \"nutrition bars\"\n    ]\n  },\n  {\n    \"category\": \"Tools & Home Improvement\",\n    \"subcategories\": [\n      \"power tools\", \"hand tools\", \"hardware\", \"paint supplies\",\n      \"safety gear\", \"tool storage\", \"plumbing tools\", \"electrical tools\"\n    ]\n  },\n  {\n    \"category\": \"Industrial & Scientific\",\n    \"subcategories\": [\n      \"lab supplies\", \"safety equipment\", \"test & measurement devices\",\n      \"industrial power supplies\", \"scientific instruments\"\n    ]\n  },\n  {\n    \"category\": \"Musical Instruments & Video Games\",\n    \"subcategories\": [\n      \"guitars\", \"keyboards\", \"drums\", \"audio interfaces\",\n      \"video games\", \"game consoles\", \"PC software\"\n    ]\n  }\n]\n\nmodule.exports = {\n    add : async(req, res, next)=>{\n        try {\n            const {title, description, price, task_type, category, subcategory, latitude, longitude} =  req.body;\n            const user = req.user;\n            const uploadedFiles = req.files?.files;\n            \n            //uploading immages\n            if (task_type == 'sell' && !uploadedFiles) {\n                throw new CustomError(400, 'Product images are required');\n            }\n            const filesArray = uploadedFiles && (Array.isArray(uploadedFiles) || typeof(uploadedFiles) == 'object')\n                ?  Array.isArray(uploadedFiles)  ? uploadedFiles : [uploadedFiles]\n                : [];\n         \n            // const fileDataArray = filesArray.map((file)=>{\n            //     const fileOriginalName = String(file.name).toLowerCase();\n            //     const fileModifiedName = `${uuidv4()}-${fileOriginalName}`;\n            //     const uploadFilePath = path.join(__dirname, '..', '..', '..', 'public', 'uploads', 'products', fileModifiedName);\n\n            //     return new Promise((resolve, reject) =>{\n            //         file.mv(uploadFilePath, (err) =>{\n            //             if(err) return reject(err);\n            //             resolve({\n            //                 file_original_name: fileOriginalName,\n            //                 file_modified_name: fileModifiedName,\n            //             })\n            //         })\n            //     })\n            // })\n            // const uploadedImages = await Promise.all(fileDataArray);\n\n            \n            const fileDataArray = filesArray.map((file)=>{\n                return new Promise((resolve, reject)=>{\n                    cloudinary.uploader.upload(file.tempFilePath, {\n                        folder: 'uploads/AI-Marketplace/products', // ðŸ‘ˆ your desired folder\n                    }).then((result)=>{\n                        resolve({\n                            public_id : result.public_id,\n                            image_format : result.secure_url.split('.').at(-1)\n                        });\n                    }).catch(error =>{\n                        reject(error);\n                    })\n                }) \n            })\n            const uploadedImages = await Promise.all(fileDataArray);\n\n            const data = {\n                title : title?.toLowerCase() || '',\n                description : description?.toLowerCase() || '',\n                price : price || 0,\n                task_type : task_type?.toString()?.toLowerCase() || 'buy',\n                category : category?.toString()?.toLowerCase() || 'other',\n                subcategory : subcategory?.toString()?.toLowerCase() || 'other',\n                images : uploadedImages,\n                created_by : user._id\n            }\n\n            //getting embeddings\n            const embeddingText = `Title : ${data.title}. Description : ${data.description}. Category : ${data.category}. Subcategory : ${data.subcategory}`;\n            // data.embedding = await getEmbedding1536(embeddingText);\n            const imageUrls = uploadedImages.map(image =>{\n                return `${process.env.CLOUDINARY_BASE_URL}/${image.public_id}.${image.image_format}`\n            })\n            data.embedding = await embedMultimodal(embeddingText, imageUrls);\n\n            //getting location using coordinates\n            const location = await getLocationUsingCoordinates(latitude, longitude);\n            location.latitude = latitude || 0;\n            location.longitude = longitude || 0;\n            location.city = getCityNameUsingLocation(location);\n            data.location = location;\n\n            //storing product in DB\n            const productCreated = await ProductModel.create(data);\n\n            res\n            .status(200)\n            .json({success : true, data : productCreated });\n\n        } catch (error) {\n            console.log(error);\n            next(error);\n        }\n    },\n    edit : async(req, res, next)=>{\n        try {\n            const {product_id, title, description, price, task_type, category, subcategory, images, latitude, longitude} \n            =  req.body;\n\n            if (!product_id) {\n                throw new CustomError(400, 'Product id id required');\n            }\n\n            //uploading new images\n            const uploadedFiles = req.files?.files;\n            if (task_type == 'sell' && !(uploadedFiles || images.length)) {\n                throw new CustomError(400, 'Product images are required');\n            }\n            //deleting old images\n            const imagesURL = images ? (typeof(images) == 'string' ? JSON.parse(images) : images) : []\n            const task = await ProductModel.findOne({_id: product_id});\n            const {dbOldImages, dbOldImagesToDelete} = getDBOldImages(task.images, imagesURL);\n            deleteImagesFromCloudinary(dbOldImagesToDelete);\n\n            const filesArray = uploadedFiles && (Array.isArray(uploadedFiles) || typeof(uploadedFiles) == 'object')\n                ?  Array.isArray(uploadedFiles)  ? uploadedFiles : [uploadedFiles]\n                : [];\n         \n            const fileDataArray = filesArray.map((file)=>{\n                return new Promise((resolve, reject)=>{\n                    cloudinary.uploader.upload(file.tempFilePath, {\n                        folder: 'uploads/AI-Marketplace/products', // ðŸ‘ˆ your desired folder\n                    }).then((result)=>{\n                        resolve({\n                            public_id : result.public_id,\n                            image_format : result.secure_url.split('.').at(-1)\n                        });\n                    }).catch(error =>{\n                        reject(error);\n                    })\n                }) \n            })\n            const uploadedImages = [...await Promise.all(fileDataArray), ...dbOldImages];\n\n            const data = {\n                title : title?.toLowerCase() || '',\n                description : description?.toLowerCase() || '',\n                price : price || 0,\n                task_type : task_type?.toString()?.toLowerCase() || 'buy',\n                category : category?.toString()?.toLowerCase() || 'other',\n                subcategory : subcategory?.toString()?.toLowerCase() || 'other',\n                images : uploadedImages,\n            }\n\n            //getting embeddings\n            const embeddingText = `Title : ${data.title}. Description : ${data.description}. Category : ${data.category}. Subcategory : ${data.subcategory}`;\n            const embeddingImageUrls = uploadedImages.map(image =>{\n                return `${process.env.CLOUDINARY_BASE_URL}/${image.public_id}.${image.image_format}`\n            })\n            data.embedding = await embedMultimodal(embeddingText, embeddingImageUrls);\n\n            //getting location using coordinates\n            if(latitude && longitude){    \n                const location = await getLocationUsingCoordinates(latitude, longitude);\n                location.latitude = latitude || 0;\n                location.longitude = longitude || 0;\n                location.city = getCityNameUsingLocation(location);\n                data.location = location;\n            }\n\n            //updating product in DB\n            await ProductModel.updateOne({_id: product_id}, {$set:data});\n\n            res\n            .status(200)\n            .json({success : true, message: 'Product updated successfully'});\n        } catch (error) {\n            console.log(error);\n            next(error);\n        }\n    },\n    list : async(req, res, next)=>{\n        try {\n            const user = req.user;\n            let {status, sort, skip, limit} = req.body;\n            \n            console.log(req.body, '=============payload products listing');\n\n            skip = skip || 0;;\n            limit = limit || 10;\n            if(status && !(status == 'active' || status == 'closed' || status == 'expired')){\n                throw new Error('Status is not valid');\n            }\n            sort = sort ? (typeof(sort)=='string' ? JSON.parse(sort) : sort) : {createdAt: -1};\n\n            let filter = {};\n\n            if(status == 'active' || status == 'expired'){\n                filter = {\n                    status,\n                    created_by : user._id\n                }\n            }else if(status == 'closed'){\n                filter = {\n                    status,\n                    $or: [\n                        {created_by : user._id},\n                        {pruchased_by: user._id}\n                    ]\n                }\n            }else{\n                filter = {\n                    $or:[\n                        {created_by : user._id},\n                        {pruchased_by: user._id}\n                    ]\n                    \n                }\n            }\n          \n            const productsQuery = ProductModel\n                .find(filter)\n                .sort(sort)\n                .skip(skip)\n                .limit(limit)\n            const countQuery = ProductModel.countDocuments(filter);\n            const [products, count] = await Promise.all([productsQuery, countQuery]);\n\n            const modifiedData = products.map(product =>{\n                const plainProduct = product.toJSON();\n                delete plainProduct.embedding;\n                return {\n                    ...plainProduct,\n                    images : product?.images.map(image =>{\n                        return `${process.env.CLOUDINARY_BASE_URL}/${image.public_id}.${image.image_format}`\n                    })\n                }\n            })\n\n            res\n            .status(200)\n            .json({success : true, data : {products : modifiedData, count}});\n        } catch (error) {\n            console.log(error);\n            next(error);\n        }\n    },\n    details : async(req, res, next)=>{\n        try {\n            const product_id =  req.params.product_id;\n            if(!product_id){\n                throw new CustomError(400, 'Product ID is required');\n            }\n\n            const data = await ProductModel.aggregate([\n                {\n                    $match: {_id : new mongoose.Types.ObjectId(product_id)}\n                },\n                {\n                    $lookup : {\n                        from : 'users',\n                        let: { user_id: '$created_by' },\n                        pipeline: [\n                            {\n                                $match: { $expr: { $eq: ['$_id', '$$user_id'] } }\n                            },\n                            {\n                                $project: {\n                                    _id: 1,\n                                    name: 1,\n                                    email: 1,\n                                    phone: 1\n                                }\n                            }\n                        ],\n                        as : 'owner'       \n                    }   \n                },\n                { $unwind : '$owner' },\n                {\n                    $lookup : {\n                        from : 'users',\n                        let: { user_id: '$purchased_by' },\n                        pipeline: [\n                            {\n                                $match: { $expr: { $eq: ['$_id', '$$user_id'] } }\n                            },\n                            {\n                                $project: {\n                                    _id: 1,\n                                    name: 1,\n                                    email: 1,\n                                    phone: 1\n                                }\n                            }\n                        ],\n                        as : 'buyer'       \n                    }   \n                },\n                { $unwind : '$buyer' },\n                {\n                    $project: {\n                        title: 1,\n                        description : 1,\n                        price: 1,\n                        task_type: 1,\n                        images: 1,\n                        category: 1,\n                        subcategory: 1,\n                        owner : 1,\n                        buyer: 1,\n                        location: 1,\n                        status: 1,\n                        inactive_status: 1,\n                        createdAt: 1\n                    }\n                }\n            ]);\n\n            if(!data || !data.length){\n                throw new CustomError(400, 'No product found');\n            }\n            \n            const modifiedData = {\n                ...data[0],\n                images : data[0]?.images.map(image =>{\n                    return `${process.env.CLOUDINARY_BASE_URL}/${image.public_id}.${image.image_format}`\n                })\n            }\n\n            // await deleteAllProducts();\n            // await deleteAllUsers();\n            res\n            .status(200)\n            .json({success : true, data : {product : modifiedData}});\n        } catch (error) {\n            console.log(error);\n            next(error);\n        }\n    },\n\n    getMatchingProducts : async(req, res, next)=>{\n        try {\n            let {product_id, cursor} = req.body;\n            if(!product_id){\n                throw new CustomError(400, 'Product ID is required');\n            }\n\n            const product = await ProductModel.findOne({_id : product_id});\n\n            const taskTypeToSearch = product.task_type == 'buy' ? 'sell' : 'buy';\n            const cityFilter = product.location?.city \n                ? \n                    { \n                        $or:[\n                            {'location.city': product.location.city},\n                            {'location.city': null}\n                        ]\n                    } \n                : {}\n\n            // Build a pagination filter if cursor exists\n            cursor = cursor ? (typeof(cursor) == 'string' ? JSON.parse(cursor) : cursor ) : null;\n            const paginationMatch = cursor\n            ? \n                {\n                    $or: [\n                        { score: { $lt: cursor.last_record_score } },\n                        { score: cursor.last_record_score, _id: { $gt: cursor.last_record_id } }\n                    ]\n                }\n            : {};\n\n            const productList = await ProductModel.aggregate([\n                {\n                    $vectorSearch: {\n                        index: \"vector_index\",\n                        path: \"embedding\",\n                        queryVector: product.embedding,\n                        filter: { \n                            status: 'active',\n                            task_type: taskTypeToSearch, \n                            subcategory : product.subcategory,\n                            created_by : {$ne: product.created_by},\n                            ...cityFilter\n                        },\n                        numCandidates: 5000,\n                        limit: 500\n                    }\n                },\n                {\n                    $lookup : {\n                        from : 'users',\n                        let: { user_id: '$created_by' },\n                        pipeline: [\n                            {\n                                $match: { $expr: { $eq: ['$_id', '$$user_id'] } }\n                            },\n                            {\n                                $project: {\n                                    _id: 1,\n                                    name: 1,\n                                    email: 1,\n                                    phone: 1\n                                }\n                            }\n                        ],\n                        as : 'owner'       \n                    }\n                },\n                { $unwind : '$owner' },\n                {\n                    $project: {\n                        score: { $meta: \"vectorSearchScore\" }, // Convert meta score into a usable field\n                        title: 1,\n                        description : 1,\n                        price: 1,\n                        task_type: 1,\n                        images: 1,\n                        category: 1,\n                        subcategory: 1,\n                        _id: 1,\n                        owner : 1,\n                        location: 1,\n                        createdAt: 1\n                    }\n                },\n                ...(cursor ? [{ $match: paginationMatch }] : []),\n                {\n                    $sort: {\n                        score: -1, _id: 1, // Primary sort: descending by vector similarity\n                    }\n                },\n                {\n                    $limit: 10\n                }\n            ]);\n\n            let modifiedProducts = productList.map(matchingProduct =>{\n                const distanceInMS = getDistanceBetweenCoordinates(\n                    matchingProduct.location.latitude, matchingProduct.location.longitude, \n                    product.location.latitude, product.location.longitude\n                )\n                const distanceInKMS = `${(distanceInMS/1000).toFixed(1)} KMS`;\n                return {\n                    ...matchingProduct,\n                    images : matchingProduct?.images.map(image =>{\n                        return `${process.env.CLOUDINARY_BASE_URL}/${image.public_id}.${image.image_format}`\n                    }),\n                    distance: distanceInKMS\n                }\n            })\n\n            if(taskTypeToSearch == 'buy'){\n                //sorting in DESC\n                modifiedProducts = modifiedProducts.sort((productA, productB) => productB.price - productA.price)\n            }else{\n                //sorting in ASC\n                modifiedProducts = modifiedProducts.sort((productA, productB) => productA.price - productB.price)\n            }\n\n\n            res.json({data : modifiedProducts});\n        } catch (error) {\n            console.log(error);\n            next(error);\n        }\n    },\n\n\n    getCategories : async(req, res, next)=>{\n        try {\n\n            const categoriesList = [];\n            categories.forEach(category => categoriesList.push(category.category));\n\n            res\n            .status(200)\n            .json({success : true, data : {categories: categoriesList}});\n        } catch (error) {\n            console.log(error);\n            next(error);\n        }\n    },\n    getSubCategories : async(req, res, next)=>{\n        try {\n            const {category_name} = req.query;\n\n            const SubCategoriesList = [];\n            const category = categories.find(category => category.category == category_name);\n\n            res\n            .status(200)\n            .json({success : true, data : {subcategories: category.subcategories}});\n        } catch (error) {\n            console.log(error);\n            next(error);\n        }\n    },\n    \n}\n\n\n","path":null,"size_bytes":25036,"size_tokens":null},"src/routes.js":{"content":"const express = require('express');\nconst router = express.Router();\n\nrouter.use('/v1', require('./modules/v1/routes'))\n\nmodule.exports = router;","path":null,"size_bytes":145,"size_tokens":null},"src/modules/v1/routes.js":{"content":"const express = require('express');\nconst router = express.Router();\n\nconst isLoggedInMiddleware = require('../../middlewares/isLoggedInMiddleware');\n\nrouter.use('/auth', require('./auth/routes'));\nrouter.use('/user', isLoggedInMiddleware, require('./user/routes'));\nrouter.use('/products', isLoggedInMiddleware, require('./products/routes'));\nrouter.use('/AI', isLoggedInMiddleware, require('./AI/routes'));\nrouter.use('/messages', isLoggedInMiddleware, require('./messages/routes'));\nrouter.use('/transactions', isLoggedInMiddleware, require('./transactions/routes'));\nmodule.exports = router;","path":null,"size_bytes":595,"size_tokens":null},"README.md":{"content":"\"# Ai-marketplace\" \n","path":null,"size_bytes":20,"size_tokens":null},"src/models/chat_rooms.js":{"content":"\nconst  mongoose = require(\"mongoose\");\nconst ObjectId = mongoose.Schema.Types.ObjectId;\n\nconst Schema = new mongoose.Schema(\n  {\n    sender: {\n      type: ObjectId,\n      ref: 'users',\n      required: true,\n    },\n    receiver: {\n      type: ObjectId,\n      ref: 'users',\n      required: true,\n    },\n  },\n  { timestamps: true }\n);\n\nmodule.exports = mongoose.model(\"chat_rooms\", Schema);","path":null,"size_bytes":388,"size_tokens":null},"src/modules/v1/products/routes.js":{"content":"const express = require('express');\nconst router = express.Router();\n\nconst controller = require('./controller');\n\nrouter.post('/add', controller.add);\nrouter.post('/edit', controller.edit);\nrouter.post('/list', controller.list);\nrouter.get('/details/:product_id', controller.details);\nrouter.post('/get-matching-products', controller.getMatchingProducts);\n\nrouter.get('/get-categories', controller.getCategories);\nrouter.get('/get-subcategories', controller.getSubCategories);\nmodule.exports = router;","path":null,"size_bytes":502,"size_tokens":null},"src/modules/v1/user/controller.js":{"content":"const userModel = require('../../../models/users');\nconst { CustomError } = require('../../../utils/customError');\nconst { matchPassword, hashPassword } = require('../../../utils/helperFunctions');\n\nmodule.exports = {\n    getDetails : async(req, res, next) =>{\n        try {\n            const response = {\n                _id : req.user._id,\n                name : req.user.name,\n                email : req.user.email,\n                phone : req.user.phone,\n                full_address: req.user.full_address || '',\n                bank_account_number: req.user.bank_account_number\n            }\n            res\n            .status(201)\n            .json({success : true, message : 'User updated successfully', response});\n        } catch (error) {\n            next(error);\n        }\n    },\n    updateProfile : async(req, res, next) =>{\n        try {\n            const {name, full_address} = req.body;\n            const userId = req.user._id;\n\n            const data = {\n                name,\n                full_address\n            }\n            await userModel.updateOne({_id : userId}, {$set : data});\n\n            const response = {\n                _id : req.user._id,\n                name,\n                email : req.user.email,\n                phone : req.user.phone,\n                full_address\n            }\n            res\n            .status(201)\n            .json({success : true, message : 'User updated successfully', response});\n        } catch (error) {\n            next(error);\n        }\n    },\n    updateBankDetails : async(req, res, next) =>{\n        try {\n            const { bank_account_number } = req.body;\n            const userId = req.user._id;\n\n            const updatedData = {\n                bank_account_number\n            }\n\n            await userModel.updateOne({_id : userId}, {$set : updatedData});\n            \n            res\n            .status(200)\n            .json({success : true, message : 'Bank details updated successfully'});\n        } catch (error) {\n            console.log(error);    \n            next(error);\n        }\n    },\n    changePassword : async(req, res, next) =>{\n        try {\n            const { old_password, new_password, confirm_password } = req.body;\n            const userId = req.user._id;\n            \n            if(!(await matchPassword(old_password, req.user.password))){\n                throw new CustomError(400, 'Old Password not matched', 'changePassword');\n            }else if(new_password != confirm_password){\n                throw new CustomError(400, 'Confirm Password not matched', 'changePassword');\n            }else if(old_password == new_password ){\n                throw new CustomError(400, 'Old and new password can\\'t be same', 'changePassword');\n            }\n\n            await userModel.updateOne({_id : userId}, {$set :{password : await hashPassword(new_password)}});\n            \n            res\n            .status(200)\n            .json({success : true, message : 'Password updated successfully'});\n        } catch (error) {\n            console.log(error);    \n            next(error);\n        }\n    },\n    logOut : async(req, res, next) =>{\n        try {\n            const userId = req.user._id;\n    \n            await userModel.updateOne({_id : userId}, {$set :{access_token : null}});\n            \n            res\n            .status(200)\n            .json({success : true, message : 'User logged out'});\n        } catch (error) {\n            console.log(error);    \n            next(error);\n        }\n    },\n}","path":null,"size_bytes":3515,"size_tokens":null},"src/utils/customError.js":{"content":"class CustomError extends Error {\n    constructor(statusCode, message, functionName) {\n      super(message ||  \"Internal Server Error\");\n      this.status = statusCode || 500;\n      this.functionName = functionName || '';\n    }\n  }\n  \nmodule.exports = {CustomError};\n  ","path":null,"size_bytes":269,"size_tokens":null},"src/modules/v1/AI/controller.js":{"content":"const express=require('express');\nconst router = express.Router();\nconst { OpenAI } = require('openai');\nconst axios = require('axios');\nconst WebSocket = require('ws');\nconst wav = require(\"node-wav\");\nconst fs = require('fs');\n\nconst { CustomError } = require('../../../utils/customError');\nconst { getSocketIO } = require('../../../config/socket/socket_service');\nlet socketIo;\n\nconst openai = new OpenAI({ apiKey : process.env.OPEN_API_KEY });\n\nconst categories = [\n  {\n    \"category\": \"Fashion\",\n    \"subcategories\": [\n      \"jeans\", \"shirts\", \"t-shirts\", \"polo shirts\", \"shorts\",\n      \"jackets\", \"sweatshirts\", \"hoodies\", \"skirts\", \"dresses\",\n      \"handbags\", \"watches\", \"shoes\", \"socks\", \"underwear\",\n      \"belts\", \"scarves\", \"sunglasses\"\n    ]\n  },\n  {\n    \"category\": \"Electronics\",\n    \"subcategories\": [\n      \"mobile phones\", \"laptops\", \"cameras\", \"headphones\",\n      \"smartwatches\", \"smart speakers\", \"televisions\", \"tablets\",\n      \"wireless earbuds\", \"routers\", \"external hard drives\",\n      \"printers\", \"monitors\", \"game consoles\"\n    ]\n  },\n  {\n    \"category\": \"Home & Kitchen\",\n    \"subcategories\": [\n      \"cookware\", \"bedding\", \"sofas\", \"dining tables\",\n      \"small kitchen appliances\", \"vacuum cleaners\", \"wall art\",\n      \"bath towels\", \"kitchen utensils\", \"coffee makers\",\n      \"mattresses\", \"desk chairs\"\n    ]\n  },\n  {\n    \"category\": \"Beauty & Personal Care\",\n    \"subcategories\": [\n      \"skincare\", \"lipstick\", \"perfume\", \"shampoo\",\n      \"conditioner\", \"body lotion\", \"oral care\", \"makeup brushes\",\n      \"hair coloring\", \"face serums\", \"facial cleansers\"\n    ]\n  },\n  {\n    \"category\": \"Books\",\n    \"subcategories\": [\n      \"fiction\", \"non-fiction\", \"childrenâ€™s books\", \"textbooks\",\n      \"audiobooks\", \"ebooks\", \"comics\", \"self-help\", \"cookbooks\"\n    ]\n  },\n  {\n    \"category\": \"Toys & Games\",\n    \"subcategories\": [\n      \"board games\", \"puzzles\", \"action figures\", \"educational toys\",\n      \"electronic toys\", \"dolls\", \"outdoor play\", \"video games\"\n    ]\n  },\n  {\n    \"category\": \"Sports & Outdoors\",\n    \"subcategories\": [\n      \"fitness equipment\", \"camping gear\", \"cycling\",\n      \"team sports gear\", \"yoga mats\", \"running shoes\",\n      \"swimwear\", \"exercise accessories\"\n    ]\n  },\n  {\n    \"category\": \"Pet Supplies\",\n    \"subcategories\": [\n      \"dog food\", \"cat food\", \"aquatic supplies\", \"pet grooming tools\",\n      \"pet toys\", \"pet beds\", \"bird supplies\", \"reptile accessories\"\n    ]\n  },\n  {\n    \"category\": \"Health & Household\",\n    \"subcategories\": [\n      \"vitamins\", \"supplements\", \"medical supplies\", \"cleaning products\",\n      \"personal care essentials\", \"first aid kits\", \"nutrition bars\"\n    ]\n  },\n  {\n    \"category\": \"Tools & Home Improvement\",\n    \"subcategories\": [\n      \"power tools\", \"hand tools\", \"hardware\", \"paint supplies\",\n      \"safety gear\", \"tool storage\", \"plumbing tools\", \"electrical tools\"\n    ]\n  },\n  {\n    \"category\": \"Industrial & Scientific\",\n    \"subcategories\": [\n      \"lab supplies\", \"safety equipment\", \"test & measurement devices\",\n      \"industrial power supplies\", \"scientific instruments\"\n    ]\n  },\n  {\n    \"category\": \"Musical Instruments & Video Games\",\n    \"subcategories\": [\n      \"guitars\", \"keyboards\", \"drums\", \"audio interfaces\",\n      \"video games\", \"game consoles\", \"PC software\"\n    ]\n  }\n]\n\nconst MAX_QUERY_LENGTH = 500; // Adjust based on model's token limits\n\nconst systemPrompt = `You are a focused sales assistant helping users buy or sell products.\n\nðŸŽ¯ Your job:\n- Understand the user's intent (buy or sell).\n- Ask clear, non-repeating follow-up questions about the product (model, brand, condition, price, etc.).\n- These Follow-up questions must be in some priority not random order.\n  1. Main Goal â†’ First, ask about the key product needs such as model, brand, condition (new/used), and price range.\n  2. Specific Details â†’ Next, ask about important preferences like features, size, color, or style.\n  Also don't ask all of these in single go.\n- Only ask 1-2 follow-up questions at a time not multiple questions, follow-up question should not be long.\n- If the user says single-word-input or short sentence then also ask good follow-up question for that.\n- You can ask upto 5-6 follow-up Questions.\n- Stay on product-related topics only, If the user asks personal or off-topic questions then Remind them \n  you're a sales assistant within this app and guide back to the product.\n- If the user asks about product availability or show me products, Then reply:\n  \"I'm currently gathering all the necessary product details. Once I have everything, I can show you the best matching products\", \n  And guide back to the product.\n\n\nCategories and Subcategories for any Product must be:\n[\n  {\"category\": \"Fashion\", \"subcategories\": [\"jeans\", \"shirts\", \"t-shirts\", \"polo shirts\", \"shorts\", \"jackets\", \"sweatshirts\", \"hoodies\", \"skirts\", \"dresses\", \"handbags\", \"watches\", \"shoes\", \"socks\", \"underwear\", \"belts\", \"scarves\", \"sunglasses\"]},\n  {\"category\": \"Electronics\", \"subcategories\": [\"mobile phones\", \"laptops\", \"cameras\", \"headphones\", \"smartwatches\", \"smart speakers\", \"televisions\", \"tablets\", \"wireless earbuds\", \"routers\", \"external hard drives\", \"printers\", \"monitors\", \"game consoles\"]},\n  {\"category\": \"Home & Kitchen\", \"subcategories\": [\"cookware\", \"bedding\", \"sofas\", \"dining tables\", \"small kitchen appliances\", \"vacuum cleaners\", \"wall art\", \"bath towels\", \"kitchen utensils\", \"coffee makers\", \"mattresses\", \"desk chairs\"]},\n  {\"category\": \"Beauty & Personal Care\", \"subcategories\": [\"skincare\", \"lipstick\", \"perfume\", \"shampoo\", \"conditioner\", \"body lotion\", \"oral care\", \"makeup brushes\", \"hair coloring\", \"face serums\", \"facial cleansers\"]},\n  {\"category\": \"Books\", \"subcategories\": [\"fiction\", \"non-fiction\", \"childrenâ€™s books\", \"textbooks\", \"audiobooks\", \"ebooks\", \"comics\", \"self-help\", \"cookbooks\"]},\n  {\"category\": \"Toys & Games\", \"subcategories\": [\"board games\", \"puzzles\", \"action figures\", \"educational toys\", \"electronic toys\", \"dolls\", \"outdoor play\", \"video games\"]},\n  {\"category\": \"Sports & Outdoors\", \"subcategories\": [\"fitness equipment\", \"camping gear\", \"cycling\", \"team sports gear\", \"yoga mats\", \"running shoes\", \"swimwear\", \"exercise accessories\"]},\n  {\"category\": \"Pet Supplies\", \"subcategories\": [\"dog food\", \"cat food\", \"aquatic supplies\", \"pet grooming tools\", \"pet toys\", \"pet beds\", \"bird supplies\", \"reptile accessories\"]},\n  {\"category\": \"Health & Household\", \"subcategories\": [\"vitamins\", \"supplements\", \"medical supplies\", \"cleaning products\", \"personal care essentials\", \"first aid kits\", \"nutrition bars\"]},\n  {\"category\": \"Tools & Home Improvement\", \"subcategories\": [\"power tools\", \"hand tools\", \"hardware\", \"paint supplies\", \"safety gear\", \"tool storage\", \"plumbing tools\", \"electrical tools\"]},\n  {\"category\": \"Industrial & Scientific\", \"subcategories\": [\"lab supplies\", \"safety equipment\", \"test & measurement devices\", \"industrial power supplies\", \"scientific instruments\"]},\n  {\"category\": \"Musical Instruments & Video Games\", \"subcategories\": [\"guitars\", \"keyboards\", \"drums\", \"audio interfaces\", \"video games\", \"game consoles\", \"PC software\"]},\n  {\"category\": \"Vehicles\", \"subcategories\": [\"cars\", \"bikes\", \"scooters\", \"trucks\", \"buses\", \"electric vehicles\", \"hybrid vehicles\", \"vans\", \"tractors\", \"rvs & campers\", \"commercial vehicles\", \"auto parts & accessories\"]}\n] \nYou will only use these categories and subcategories.\n\n\nðŸ”• Do NOT:\n- Say \"wait\" or \"hold on\"\n- Mention apps or platforms, online or offline. Because platform is this app only.\n- Gathering options or display products list.\n- Searching, Filtering items, Displaying or Fetching Products.\n- Mention city or area.\n- Mention \"two quick questions 1. 2.\" and all these kind of things.\n`;\n\nconst chatEndDetectionSystemPrompt = `\nYou are an AI that detects if a user message ends a conversation. \nMust Reply ONLY as JSON: {\"chat_ended\": true} or {\"chat_ended\": false}. \nDo not add any extra text.\n`;\n\nconst chatEndedSummarySystemPrompt = `\nYou are a focused sales assistant helping users buy or sell Products.\nYour goal is to analyze and Summarize the chat conversation.\n\nCategories and Subcategories for any Product must be:\n[\n  {\"category\": \"Fashion\", \"subcategories\": [\"jeans\", \"shirts\", \"t-shirts\", \"polo shirts\", \"shorts\", \"jackets\", \"sweatshirts\", \"hoodies\", \"skirts\", \"dresses\", \"handbags\", \"watches\", \"shoes\", \"socks\", \"underwear\", \"belts\", \"scarves\", \"sunglasses\"]},\n  {\"category\": \"Electronics\", \"subcategories\": [\"mobile phones\", \"laptops\", \"cameras\", \"headphones\", \"smartwatches\", \"smart speakers\", \"televisions\", \"tablets\", \"wireless earbuds\", \"routers\", \"external hard drives\", \"printers\", \"monitors\", \"game consoles\"]},\n  {\"category\": \"Home & Kitchen\", \"subcategories\": [\"cookware\", \"bedding\", \"sofas\", \"dining tables\", \"small kitchen appliances\", \"vacuum cleaners\", \"wall art\", \"bath towels\", \"kitchen utensils\", \"coffee makers\", \"mattresses\", \"desk chairs\"]},\n  {\"category\": \"Beauty & Personal Care\", \"subcategories\": [\"skincare\", \"lipstick\", \"perfume\", \"shampoo\", \"conditioner\", \"body lotion\", \"oral care\", \"makeup brushes\", \"hair coloring\", \"face serums\", \"facial cleansers\"]},\n  {\"category\": \"Books\", \"subcategories\": [\"fiction\", \"non-fiction\", \"childrenâ€™s books\", \"textbooks\", \"audiobooks\", \"ebooks\", \"comics\", \"self-help\", \"cookbooks\"]},\n  {\"category\": \"Toys & Games\", \"subcategories\": [\"board games\", \"puzzles\", \"action figures\", \"educational toys\", \"electronic toys\", \"dolls\", \"outdoor play\", \"video games\"]},\n  {\"category\": \"Sports & Outdoors\", \"subcategories\": [\"fitness equipment\", \"camping gear\", \"cycling\", \"team sports gear\", \"yoga mats\", \"running shoes\", \"swimwear\", \"exercise accessories\"]},\n  {\"category\": \"Pet Supplies\", \"subcategories\": [\"dog food\", \"cat food\", \"aquatic supplies\", \"pet grooming tools\", \"pet toys\", \"pet beds\", \"bird supplies\", \"reptile accessories\"]},\n  {\"category\": \"Health & Household\", \"subcategories\": [\"vitamins\", \"supplements\", \"medical supplies\", \"cleaning products\", \"personal care essentials\", \"first aid kits\", \"nutrition bars\"]},\n  {\"category\": \"Tools & Home Improvement\", \"subcategories\": [\"power tools\", \"hand tools\", \"hardware\", \"paint supplies\", \"safety gear\", \"tool storage\", \"plumbing tools\", \"electrical tools\"]},\n  {\"category\": \"Industrial & Scientific\", \"subcategories\": [\"lab supplies\", \"safety equipment\", \"test & measurement devices\", \"industrial power supplies\", \"scientific instruments\"]},\n  {\"category\": \"Musical Instruments & Video Games\", \"subcategories\": [\"guitars\", \"keyboards\", \"drums\", \"audio interfaces\", \"video games\", \"game consoles\", \"PC software\"]},\n  {\"category\": \"Vehicles\", \"subcategories\": [\"cars\", \"bikes\", \"scooters\", \"trucks\", \"buses\", \"electric vehicles\", \"hybrid vehicles\", \"vans\", \"tractors\", \"rvs & campers\", \"commercial vehicles\", \"auto parts & accessories\"]}\n] \nYou will only use these categories and subcategories.\n\nSummarize the chat conversation with the product intent.\nRespond ONLY with the raw plain JSON object.\n\nâœ³ï¸ JSON Format:\nYou MUST Return ONLY the raw JSON Plain Object. Do NOT include any extra text, explanation, or formatting before or after.\n{\n  \"title\": \"\",\n  \"description\": \"\",\n  \"price\": \"\",\n  \"category\": \"\",\n  \"subcategory\": \"\",\n  \"task_type\": \"\"\n}\n\nJSON Fields Explaination\n{\n  \"title\": Short, Focused product title of the entire conversation, \n    It can't be empty, whether user input very less details\n  \"description\": A concise summary **ONLY of the information provided by the user** during the chat. \n    It must be benefitâ€‘focused, in natural sentences ( max 100 words). \n    âš ï¸ Do NOT include details the user did not respond to.\n    âš ï¸ Do NOT mention any assistant questions, missing responses, or what was not answered.\n    âš ï¸ Do NOT say things like â€œuser was asked about...â€, â€œno details were providedâ€.\n  \"price\": Number // user provided or inferred, 0 if not mentioned\n  \"category\": \"main product category\", // Only From the categories array mentioned above\n  \"subcategory\": \"specific product type\",  // Only From the sub-categories array mentioned above\n  \"task_type\": either \"buy\" or \"sell\",  // based on userâ€™s intent whether he wants to \"buy\" or \"sell\" ,\n    bydefault it will be \"buy\" if not confirmed\n}`;\n \nconst conversationHistory = {};\nconst streamingHistory = {};\nconst realTimeSessions = {};\nconst webSocketInstances = {};\nconst audioChunksHistory = {};\n\nlet audioChunks = [];\n\nconst chatAssistant = async(req, res, next)=>{\n    try {           \n        const { user_query_text } = req.body;\n        if(!user_query_text){\n            throw new CustomError(400, 'Please send user query');\n        }\n\n        // console.log('chat bot api hitting', req.body);\n        // console.log(conversationHistory, '-------------conversationHistory')\n        // console.log(streamingHistory, '-------------streamingHistory')\n        // console.log(realTimeSessions, '-------------realTimeSessions')\n        // console.log(webSocketInstances, '-------------webSocketInstances')\n\n        const user_id = req.user._id;\n        socketIo = getSocketIO();\n\n        if(await isUserWantsToEndChat(user_query_text)){\n          const chatEndedSummmary = await getChatEndedSummary(user_id);\n\n          //clear chat historys\n          clearChatHistory(user_id);\n          //closing websocket\n          closeWS(user_id);\n          //clear real time sessions\n          clearRealTimeSessions(user_id);\n\n          //sending response to user\n          socketIo.to(user_id.toString()).emit('chat_ended', chatEndedSummmary);\n        }\n        else{\n          salesAssistant(user_id, user_query_text)\n        }\n\n        return res.status(200).json({\n            success: true,\n            message: \"Success\"\n        });\n    } catch (error) {\n        console.log(error, '--------error in chat bot api');\n        next(error);\n    }\n}\n\nmodule.exports = {\n   chatAssistant,\n\n   closeWS,\n   clearRealTimeSessions,\n   clearChatHistory\n}\n\n\n//ChatBot Query Handlers\nasync function isUserWantsToEndChat(message){\n  try {\n    const completion = await openai.chat.completions.create({\n      model: process.env.OPEN_API_GPT_4o_MINI_MODEL,\n      messages: [\n        { role: \"system\", content: chatEndDetectionSystemPrompt },\n        { role: \"user\", content: `Message: \"${message}\"` }\n      ],\n    });\n\n    const responseText = completion.choices[0].message.content;\n    const parsed = JSON.parse(responseText);\n    console.log(parsed, '========end detection');\n    return parsed.chat_ended;\n  } catch (err) {\n    console.error(\"âŒ Failed to detect chat-end message:\");\n    throw err;\n  }\n}\n\nasync function getChatEndedSummary(user_id){\n   try {\n\n    if(!conversationHistory[user_id]){\n      return {\n        \"title\": \"\",\n        \"description\": \"\",\n        \"price\": \"\",\n        \"category\": \"\",\n        \"subcategory\": \"\",\n        \"task_type\": \"\"\n      }\n    }\n\n    const completion = await openai.chat.completions.create({\n      model: process.env.OPEN_API_GPT_5_MINI_MODEL,\n      messages: [\n        { role: \"system\", content: chatEndedSummarySystemPrompt },\n        ...conversationHistory[user_id]\n      ],\n    });\n\n    const responseText = completion.choices[0].message.content;\n    const parsed = JSON.parse(responseText);\n\n    return parsed;\n  } catch (err) {\n    console.error(\"âŒ Failed to get chat ended summary:\", err);\n    throw err;\n  }\n}\n\nasync function salesAssistant(user_id, message) {\n  message = message.length > MAX_QUERY_LENGTH ? message.slice(0, MAX_QUERY_LENGTH) : message ;\n    \n  conversationHistory[user_id] = !conversationHistory[user_id]\n      ?   [ {role : 'user', content : message} ]\n      :   [\n              ...conversationHistory[user_id], \n              {role : 'user', content : message} \n          ]\n\n  streamingHistory[user_id] = !streamingHistory[user_id]\n      ?   \n        [{\n          type: \"message\",\n          role: \"user\",\n          content: [{type: \"input_text\",text: message}]\n        }]\n      :\n        [\n          ...streamingHistory[user_id], \n          {\n            type: \"message\",\n            role: \"user\",\n            content: [{type: \"input_text\",text: message}]\n          }\n        ] \n\n\n  if(!realTimeSessions[user_id]){\n    realTimeSessions[user_id] = await createRealtimeSession();\n  }\n  const wsUrl = realTimeSessions[user_id];\n\n  let ws;\n  if(!webSocketInstances[user_id] || webSocketInstances[user_id].readyState !== 1){    \n\n    closeWS(user_id);\n\n    ws = new WebSocket(wsUrl, {\n      headers: { Authorization: `Bearer ${process.env.OPEN_API_KEY}` }\n    });\n\n    webSocketInstances[user_id] = ws;\n\n    if (!ws._listenersAttached) {\n\n      // attach listeners ONCE\n      ws.on(\"open\", () => {\n        console.log(\"===== WebSocket Connected\");\n\n        ws.send(JSON.stringify({\n          type: \"response.create\",\n          response: {\n            instructions: systemPrompt\n          }\n        }));\n\n      });\n\n      ws.on(\"message\", (data) => handleMessage(user_id, data));\n      ws.on(\"close\", () => closeWS(user_id));\n      ws.on(\"error\", () => closeWS(user_id));\n\n      ws._listenersAttached = true;\n    }\n\n  }else{\n    ws = webSocketInstances[user_id];\n  }\n  \n  console.log(ws.readyState, '==========ws');\n\n  const webSocketPayload = {\n    type: \"response.create\",\n    response: {\n      instructions: systemPrompt,\n      input: streamingHistory[user_id],\n       // ðŸ”¥ FIX: specify audio format\n      // output_audio: {\n      //   format: \"pcm16\",\n      //   sample_rate: 24000      // recommended by OpenAI\n      // },\n      // output_audio_format: \"pcm16\",\n      output_modalities: [\"audio\"]\n    }\n  }\n\n  // let webSocketPayload;\n\n  if(ws.readyState == 0){\n\n    // webSocketPayload = {\n    //   type: \"response.create\",\n    //   response: {\n    //     instructions: systemPrompt,\n    //     input: streamingHistory[user_id],\n    //     // ðŸ”¥ FIX: specify audio format\n    //     output_audio: {\n    //       format: \"pcm16\",\n    //       sample_rate: 24000      // recommended by OpenAI\n    //     },\n    //     // output_audio_format: \"pcm16\",\n    //     output_modalities: [\"audio\"]\n    //   }\n    // }\n\n    ws.once(\"open\", () => {\n      console.log('=====> OpenAI Websocket Connected');\n      ws.send(JSON.stringify(webSocketPayload));\n    });\n  }\n  else{\n    //  webSocketPayload = {\n    //     type: \"response.create\",\n    //     response: {\n    //       instructions: systemPrompt,\n    //       input: streamingHistory[user_id],\n    //       output_modalities: [\"audio\"]\n    //     }\n    //   }\n\n    ws.send(JSON.stringify(webSocketPayload));\n  }\n \n}\n\n\n//Incoming websocket event handlers\nfunction handleMessage(user_id, data) {\n  const msg = JSON.parse(data.toString());\n  console.log(msg.type, '======message type');\n\n  // AUDIO DELTAS\n  if (msg.type === \"response.output_audio.delta\") {\n      // console.log('==========audio chunk');\n\n      const base64 = msg.delta;\n\n      // const audioBuffer = Buffer.from(base64, \"base64\");\n      // audioChunks.push(audioBuffer);\n\n      //sending audio-chunk to user\n      audioChunksHistory[user_id] = audioChunksHistory[user_id] \n        ? [...audioChunksHistory[user_id], base64]\n        : [base64];\n\n      if(audioChunksHistory[user_id].length == 5){\n        socketIo.to(user_id.toString()).emit('audio_chunk', {audio_base64_list: audioChunksHistory[user_id]});  \n        audioChunksHistory[user_id] = null;\n      }\n      // socketIo.to(user_id.toString()).emit('audio_chunk', {audio_base64: base64});\n  }\n  else if (msg.type === \"response.output_audio_transcript.delta\") {\n      // console.log('=======text chunk', msg.delta);\n\n      //sending text-chunk to user\n      socketIo.to(user_id.toString()).emit('text_chunk', {text: msg.delta});\n  }\n  else if(msg.type === 'response.content_part.done'){\n      const message = msg.part.transcript;\n\n      if(audioChunksHistory[user_id]){\n        socketIo.to(user_id.toString()).emit('audio_chunk', {audio_base64_list: audioChunksHistory[user_id]});  \n        audioChunksHistory[user_id] = null;\n      }\n\n      //sending full-text message to user\n      socketIo.to(user_id.toString()).emit('text_message', {text: message});\n\n      conversationHistory[user_id] = [\n          ...conversationHistory[user_id], \n          {role : 'assistant', content : message} \n      ]\n  }\n  else if (msg.type === \"response.done\") {\n    console.log(\"Done.\");\n    // playAudioChunks();\n  }\n  \n}\n\n//Helping functions\nasync function createRealtimeSession() {\n  try {\n    const session = await axios.post(\n      \"https://api.openai.com/v1/realtime/sessions\",\n      {\n        model: process.env.OPEN_API_REALTIME_MODEL,\n        modalities: [\"text\", \"audio\"],\n        voice: \"alloy\", //'alloy', 'ash', 'ballad', 'coral', 'echo', 'sage', 'shimmer', 'verse', 'marin', and 'cedar'.\n        // the correct key now\n        output_audio_format: \"pcm16\"\n      },\n      {\n        headers: {\n          Authorization: `Bearer ${process.env.OPEN_API_KEY}`,\n          \"Content-Type\": \"application/json\",\n        }\n      }\n    );\n\n    const clientSecret = session.data.client_secret.value;\n\n    const wsUrl =\n      `wss://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-12-17` +\n      `&client_secret=${clientSecret}`;\n\n    console.log(\"WS:\", wsUrl);\n    return wsUrl;\n  } catch (err) {\n    console.log(\"Session error:\", err.response?.data || err);\n    throw err;\n  }\n}\n\n//Clearing chatbot streaming ws-connections and Websockets\nfunction closeWS(user_id) {\n  const ws = webSocketInstances[user_id];\n\n  if (ws) {\n    try { ws.removeAllListeners(); } catch (e) {}\n    try { ws.terminate(); } catch (e) {}\n\n    ws._listenersAttached = false;\n    webSocketInstances[user_id] = null;\n  }\n}\nfunction clearRealTimeSessions(user_id){\n  //clearing real time sessions\n  if(realTimeSessions[user_id]){\n    realTimeSessions[user_id] = null;\n  }\n}\nfunction clearChatHistory(user_id){\n  //clearing chat history\n  if(conversationHistory[user_id]){  \n    conversationHistory[user_id] = null;\n  }\n\n  //clearing streaming history\n  if(streamingHistory[user_id]){  \n    streamingHistory[user_id] = null;\n  }\n\n  if(audioChunksHistory[user_id]){\n    audioChunksHistory[user_id] = null;\n  }\n}\n\n\nfunction playAudioChunks() {\n  const pcm = Buffer.concat(audioChunks);\n\n  // Convert PCM16 â†’ Float32 for high quality WAV\n  const sampleCount = pcm.length / 2;\n  const float32 = new Float32Array(sampleCount);\n\n  for (let i = 0; i < sampleCount; i++) {\n    float32[i] = pcm.readInt16LE(i * 2) / 32768;\n  }\n\n  const wavData = wav.encode([float32], {\n    sampleRate: 24000,\n    float: true,\n    bitDepth: 32,\n  });\n\n  fs.writeFileSync(\"output.wav\", wavData);\n  console.log(\"ðŸ”Š Saved clean WAV â†’ output.wav\");\n}\n\n// 109780621431\n\n","path":null,"size_bytes":22606,"size_tokens":null},"src/modules/v1/AI/routes.js":{"content":"const express=require('express');\nconst router = express.Router();\n\nconst controller = require('./controller');\n\nrouter.post('/get-query-info', controller.chatAssistant);\n\nmodule.exports = router;","path":null,"size_bytes":196,"size_tokens":null},"src/models/products.js":{"content":"\nconst  mongoose = require(\"mongoose\");\nconst ObjectId = mongoose.Schema.Types.ObjectId;\n\nconst Schema = new mongoose.Schema(\n  {\n    title: {\n      type: String,\n      required: true,\n    },\n    description: {\n      type: String,\n      required: true,\n    },\n    price: {\n      type: Number,\n      required: true,\n    },\n    task_type: { //buy or sell\n      type : String,\n      required : true\n    },\n    category: {\n      type : String,\n      required : true\n    },\n    subcategory: {\n      type : String,\n      required : true\n    },\n    status:{ //active, closed or expired\n      type: String,\n      default: 'active',\n    },\n    purchased_by : {\n      type : ObjectId,\n      ref :  'users',\n    },\n    created_by : {\n      type : ObjectId,\n      ref :  'users',\n      required : true,\n    },\n    images : {\n        type : Array,\n        default : []\n    },\n    embedding : [Number], //It will contain embeddings of 1024 dimensions using voyage model\n    location: { type: Object }\n  },\n  { timestamps: true }\n);\n\nmodule.exports = mongoose.model(\"products\", Schema);","path":null,"size_bytes":1071,"size_tokens":null},"src/config/socket/socket_service.js":{"content":"let io;\n\nfunction setSocketIO(socketInstance) {\n    io = socketInstance;\n}\n\nfunction getSocketIO() {\n    if (!io) throw new Error(\"Socket.io not initialized\");\n    return io;\n}\n\nmodule.exports = { setSocketIO, getSocketIO };\n","path":null,"size_bytes":225,"size_tokens":null},"src/modules/v1/auth/routes.js":{"content":"\nconst express=require('express');\nconst router = express.Router();\n\nconst controller = require('./controller');\n\nrouter.post('/register', controller.register);\nrouter.post('/verify-otp', controller.verifyOTP);\nrouter.post('/resend-otp', controller.resendOTP);\nrouter.post('/reset-password', controller.resetPassword);\nrouter.post('/login-by-phone', controller.loginByPhone);\nrouter.post('/login-by-email', controller.loginByEmail);\n// router.post('/verify-link', controller.verifyLink) //two purpose\n// router.post('/forgot-password', controller.forgotPassword)\n// router.post('/login', controller.login)\n\nmodule.exports = router;","path":null,"size_bytes":631,"size_tokens":null},"src/modules/v1/user/routes.js":{"content":"const express=require('express');\nconst router = express.Router();\n\nconst controller = require('./controller');\n\nrouter.get('/details', controller.getDetails)\nrouter.put('/update-profile', controller.updateProfile)\nrouter.put('/update-bank-details', controller.updateBankDetails)\nrouter.put('/change-password', controller.changePassword)\nrouter.get('/logout', controller.logOut)\nmodule.exports = router;\n","path":null,"size_bytes":404,"size_tokens":null},"src/config/sendgrid.js":{"content":"const sgMail = require('@sendgrid/mail');\nsgMail.setApiKey(process.env.SENDGRID_API_KEY);\n\nmodule.exports = sgMail;\n","path":null,"size_bytes":116,"size_tokens":null},"src/modules/v1/messages/controller.js":{"content":"const mongoose = require('mongoose');\nconst ObjectId = mongoose.Types.ObjectId;\n\nconst cloudinary = require('cloudinary').v2;\ncloudinary.config({\n    cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\n    api_key: process.env.CLOUDINARY_API_KEY,\n    api_secret: process.env.CLOUDINARY_API_SECRET,\n});\n\n\nconst MessageModel = require('../../../models/messages');\nconst { getSocketIO } = require('../../../config/socket/socket_service');\nconst { getChatRoomId } = require('../../../utils/helperFunctions');\n\nmodule.exports = {\n    sendMessage : async(req, res, next)=>{\n        try {\n            const {receiver_id, message_type, text_message, voice_duration, voice_status} =  req.body;\n            const user = req.user;\n            \n            const data = {\n                sender: new ObjectId(user._id),\n                receiver: new ObjectId(receiver_id),\n                message_type,\n            }\n            \n            if(message_type == 'text'){\n                data.text_message = text_message;\n\n                // const socketIO = getSocketIO();\n                // socketIO.to(receiver_id).emit(\"chat\", { message_type, text_message});\n            }\n            else if(message_type == 'voice'){\n                data.voice_status = voice_status;\n                data.voice_duration = voice_duration || 0;\n            }\n            else if(message_type == 'media'){\n                const uploadedFiles = req.files?.files;\n                if(!uploadedFiles){\n                    throw new CustomError(400, 'Media is required');\n                }\n                const filesArray = uploadedFiles && (Array.isArray(uploadedFiles) || typeof(uploadedFiles) == 'object')\n                    ?  Array.isArray(uploadedFiles)  ? uploadedFiles : [uploadedFiles]\n                    : [];\n\n                const fileDataArray = filesArray\n                .filter(file => file.size/(1024*1024) <= 5 ) //less then 5 mb file.size is in bytes\n                .map((file)=>{\n                    return new Promise((resolve, reject)=>{\n                        cloudinary.uploader.upload(file.tempFilePath, {\n                            folder: 'uploads/AI-Marketplace/chat-media', // ðŸ‘ˆ your desired folder\n                            resource_type: \"auto\" // ðŸ‘ˆ handles images, pdfs, docs, videos, etc.\n                        }).then((result)=>{\n                            resolve({\n                                public_id : result.public_id,\n                                media_format : result.format,\n                                resource_type: result.resource_type,\n                                original_filename: file.name\n                            });\n                        }).catch(error =>{\n                            reject(error);\n                        })\n                    }) \n                })\n                const uploadedMediaList = await Promise.all(fileDataArray);\n                data.media_list = uploadedMediaList;\n\n                //sending socket to receiver\n                const mediaList = data?.media_list?.map(media =>{\n                    return {\n                        media_format: media.media_format,\n                        original_filename: media.original_filename,\n                        url: `${process.env.CLOUDINARY_BASE_URL_CHAT_MEDIA}/${media.resource_type}/upload/v1751423778/${media.public_id}.${media.media_format}`\n                    }  \n                })\n                const socketIO = getSocketIO();\n                const chatRoomId = await getChatRoom(user._id, receiver_id);\n                socketIO.to(chatRoomId).emit(\"getMessage\", { \n                    senderId: user._id,\n                    receiverId: receiver_id,\n                    message_type,\n                    media_list: mediaList\n                });\n            }\n\n            //storing product in DB\n            const messageAdded = await MessageModel.create(data);\n\n            res\n            .status(200)\n            .json({success : true });\n\n        } catch (error) {\n            console.log(error);\n            next(error);\n        }\n    },\n\n    getMessages : async(req, res, next)=>{\n        try {\n            let {receiver_id, skip, limit} =  req.query;\n            const user = req.user;\n            skip = skip || 0;\n            limit = limit || 10;\n            \n            const filter = {\n                sender: { $in: [new ObjectId(user._id), new ObjectId(receiver_id)] },\n                receiver: { $in: [new ObjectId(user._id), new ObjectId(receiver_id)] },\n            };\n\n            //storing product in DB\n            let messages = await MessageModel\n                .find(filter)\n                .sort({createdAt: -1})\n                .skip(skip)\n                .limit(limit);\n\n            messages = messages.map(message =>{\n                if(message.message_type != 'media')return message;\n                message.media_list = message?.media_list?.map(media =>{\n                    return {\n                        media_format: media.media_format,\n                        original_filename: media.original_filename,\n                        url: `${process.env.CLOUDINARY_BASE_URL_CHAT_MEDIA}/${media.resource_type}/upload/v1751423778/${media.public_id}.${media.media_format}`\n                    }  \n                })\n                return message;\n            })\n\n            res\n            .status(200)\n            .json({success : true, data: {messages} });\n\n        } catch (error) {\n            console.log(error);\n            next(error);\n        }\n    },\n\n    getChatRoom : async(req, res, next)=>{\n        try {\n            let {receiver_id} =  req.query;\n            if(!receiver_id){\n                throw new CustomError(400, 'Receiver id is required');\n            }\n            \n            const user = req.user;\n            \n            const chatRoomId = await getChatRoomId(user._id, receiver_id);\n\n            return res\n            .status(200)\n            .json({success : true, data: { roomId: chatRoomId} });\n        } catch (error) {\n            console.log(error);\n            next(error);\n        }\n    },\n}","path":null,"size_bytes":6104,"size_tokens":null},"src/modules/v1/transactions/routes.js":{"content":"const express = require('express');\nconst router = express.Router();\n\nconst controller = require('./controller');\n\nrouter.post('/close-deal', controller.closeDeal);\n\nmodule.exports = router;","path":null,"size_bytes":190,"size_tokens":null},"src/modules/v1/messages/routes.js":{"content":"const express = require('express');\nconst router = express.Router();\n\nconst controller = require('./controller');\n\nrouter.post('/', controller.sendMessage);\nrouter.get('/', controller.getMessages);\nrouter.get('/chat-room', controller.getChatRoom);\n\nmodule.exports = router;","path":null,"size_bytes":273,"size_tokens":null},"src/models/messages.js":{"content":"\nconst  mongoose = require(\"mongoose\");\nconst ObjectId = mongoose.Schema.Types.ObjectId;\n\nconst Schema = new mongoose.Schema(\n  {\n    sender: {\n      type: ObjectId,\n      ref: 'users',\n      required: true,\n    },\n    receiver: {\n      type: ObjectId,\n      ref: 'users',\n      required: true,\n    },\n    message_type: {\n      type: String, //text, voice, media(image, document and pdf) or offer\n      required: true,\n    },\n\n    text_message: {\n      type : String,  \n    },\n\n    voice_duration: { //in seconds\n        type: Number\n    },\n    voice_status: { //missed, recieved\n        type: String\n    },\n\n    media_list: { //if we are attaching any media inside the chat\n        type: Array\n    },\n    \n    offered_price: {\n      type: Number\n    },\n    offer_status: { //pending, accepted or rejected\n      type: String\n    },\n    offered_by: { //who will generate, accept or reject\n      type: ObjectId,\n      ref: 'users',\n    }\n  },\n  { timestamps: true }\n);\n\nmodule.exports = mongoose.model(\"messages\", Schema);","path":null,"size_bytes":1020,"size_tokens":null},"src/config/socket/socket.js":{"content":"const {Server} = require('socket.io');\nconst { createOffer, acceptOffer, rejectOffer, clearPreviousChatWebSocket } = require('../../utils/helperFunctions');\nconst {setSocketIO} = require('./socket_service');\nconst { closeWS, clearRealTimeSessions, clearChatHistory } = require('../../modules/v1/AI/controller');\n\nlet io;\n\nconst initializeSocketServer=(server)=>{\n\n    io = new Server(server,  {\n        cors: {\n            origin: \"*\", // ðŸ”¥ Allow all origins\n            methods: [\"GET\", \"POST\"],\n        },\n    });\n\n    setSocketIO(io);\n\n    // âœ… Handle socket connections\n    io.on(\"connection\", (socket) => {\n        console.log(\"ðŸŸ¢ Socket connected:\", socket.id);\n\n        //To Join a room\n        socket.on(\"createRoom\", (data) => {\n            console.log(\"ðŸ“© Socket joined room:\", data);\n            socket.join(data.roomId);\n\n            // clearPreviousChatWebSocket(data.roomId);\n            closeWS(data.roomId);\n            clearRealTimeSessions(data.roomId);\n            clearChatHistory(data.roomId);\n        });\n        //To Leave a room\n        socket.on(\"closeChat\", (data) => {\n            console.log(\"ðŸ“© Socket leaved room:\", data);\n            socket.leave(data.roomId);\n        });\n\n\n        //To Send a message\n        socket.on(\"sendMessage\", (data) => {\n            console.log(\"ðŸ“© Socket sending message:\", data);\n            socket.to(data.roomId).emit('getMessage', data);\n        });\n\n\n        //To Send Offer\n        socket.on(\"sendOffer\", async(data) => {\n            console.log(\"ðŸ“© Socket send offer:\", data);\n            const offerId = await createOffer(data);\n            socket.to(data.roomId).emit('getOffer', {...data, offerId});\n        });\n        //To Accept offer\n        socket.on(\"acceptOffer\", (data) => {\n            console.log(\"ðŸ“© Socket accept offer:\", data);\n            acceptOffer(data);\n            socket.to(data.roomId).emit('offerAccepted', data);\n        })\n        //To Decline offer\n        socket.on(\"declineOffer\", (data) => {\n            console.log(\"ðŸ“© Socket declined offer:\", data);\n            rejectOffer(data);\n            socket.to(data.roomId).emit('offerDeclined', data);\n        });\n\n\n        // Disconnect\n        socket.on(\"disconnect\", () => {\n            console.log(\"ðŸ”´ Socket disconnected:\", socket.id);\n        });\n    });\n}\n\nmodule.exports = {initializeSocketServer}","path":null,"size_bytes":2368,"size_tokens":null},"src/middlewares/errorMiddleware.js":{"content":"const errorMiddleware = (err, req, res, next) =>{\n    const statusCode = err.status || 500;\n    const message = err.message || 'Internal server error';\n    return res.status(statusCode).json({\n        message : message,\n        success : false,\n        data : null,\n        error : err\n    })\n}\n\nmodule.exports = {errorMiddleware}","path":null,"size_bytes":330,"size_tokens":null},"src/models/users.js":{"content":"const  mongoose = require(\"mongoose\");\n\nconst UserSchema = new mongoose.Schema(\n  {\n    name: {\n      type: String,\n      required: true,\n    },\n    phone: {\n      type: String,\n      required: true,\n    },\n    email: {\n      type: String,\n      required: true,\n    },\n    password: {\n      type: String,\n      required: true,\n    },\n    otp: {\n      type: Number,\n    //   required: true,\n    },\n    otp_expiry_time: {\n      type: Date,\n    //   required: true,\n    },\n    otp_check_remaining_limit: {\n      type: Number,\n    //   required: true,\n    },\n    otp_type : {\n      type  : String, //logged_in, forgot_password\n    },\n    access_token: {\n      type: String,\n    //   required: true,\n    },\n    full_address: {\n      type: String,\n    //   required: true,\n    },\n    bank_account_number: {\n      type: String,\n    //   required: true,\n    },\n  },\n  { timestamps: true }\n);\n\nmodule.exports = mongoose.model(\"users\", UserSchema);\n","path":null,"size_bytes":939,"size_tokens":null},"src/utils/cron.js":{"content":"const cron = require('node-cron');\n\nconst productsModel = require('../models/products');\n\ncron.schedule('0 0 * * *', async()=>{\n\n    const currentDate = new Date();\n    currentDate.setDate(currentDate.getDate() - 60);\n    const taskCreationDate = currentDate;\n\n    await productsModel.updateMany({\n        status: 'active',\n        createdAt: { $lt: taskCreationDate}\n    },{\n        status: 'expired'\n    })\n})","path":null,"size_bytes":411,"size_tokens":null},"src/models/transactions.js":{"content":"const  mongoose = require(\"mongoose\");\nconst ObjectId = mongoose.Schema.Types.ObjectId;\n\nconst Schema = new mongoose.Schema(\n  {\n    user_id: {\n      type: ObjectId,\n      ref: 'users',\n      required: true,\n    },\n    seller_id: {\n      type: ObjectId,\n      ref: 'users',\n    },\n    product_id: {\n      type: ObjectId,\n      ref: 'products',\n      required: true,\n    },\n    amount: {\n      type: Number,\n      required: true,\n    },\n    method: { \n      type: String,\n      required: true,\n    },\n    description: {\n      type: String,\n    },\n    status: { //pending, success\n      type: String,\n      required: true,\n    },\n    transaction_id: {\n      type: String,\n      required: true,\n    },\n    transaction_type:  { //credit or debit ( for Admin )\n      type: String,\n      required: true,\n    },\n    commission:  { \n      type: Number,\n      required: true,\n    },\n    paidAt: {\n      type: Date,\n    },\n  },\n  { timestamps: true }\n);\n\nmodule.exports = mongoose.model(\"transactions\", Schema);\n","path":null,"size_bytes":1002,"size_tokens":null},"src/modules/v1/transactions/controller.js":{"content":"const mongoose = require('mongoose');\nconst ObjectId = mongoose.Types.ObjectId;\nconst cloudinary = require('cloudinary').v2;\n\ncloudinary.config({\n    cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\n    api_key: process.env.CLOUDINARY_API_KEY,\n    api_secret: process.env.CLOUDINARY_API_SECRET,\n});\n\nconst transactionsModel = require('../../../models/transactions');\n\nmodule.exports = {\n    closeDeal : async(req, res, next)=>{\n        try {\n            const {seller_id, amount, product_id, method, description, status, paidAt, transaction_id, commission} =  req.body;\n            const user = req.user;\n            \n            const data = {\n                user_id: new ObjectId(user._id),\n                seller_id: new ObjectId(seller_id),\n                amount,\n                method,\n                description,\n                status,\n                paidAt: paidAt || new Date(),\n                product_id: product_id,\n                transaction_id: transaction_id || '123456',\n                transaction_type: 'credit',\n                commission\n            }\n            \n            //storing transaction in DB\n            await transactionsModel.create(data);\n\n            res\n            .status(200)\n            .json({ success : true });\n\n        } catch (error) {\n            console.log(error);\n            next(error);\n        }\n    },\n}","path":null,"size_bytes":1362,"size_tokens":null}},"version":2}